// --------------- 4. Шаблон Reactor.

// --- 4.1 Блокирующий ввод/вывод.

// Операции ввода/вывода являются одними из самых медленных. Такие операции 
//      не требуют больших затрат процессорного времени, но вносят задержку 
//      между отправкой запроса и завершением операции. Например, доступ 
//      к ОЗУ занимает наносекунды, а доступ к диску несколько миллисекунд.

// Блокирующий ввод/вывод - это механизм блокирующий выполнение потока 
//      до завершения операций ввода/вывода. Например, поток может ожидать 
//      получения данных с диска или пользовательского ввода.

// Сервер, реализующий такой механизм, не способен обрабатывать несколько 
//      соединений в одном потоке. Операции ввода/вывода через сокет будут 
//      блокировать обработку других соединений. Поэтому для каждого нового 
//      подключения создается новый поток. Такой подход будет неэффективен, 
//      поскольку заблокированые потоки будут продолжать потреблять системные 
//      ресурсы.

// --- 4.2 Неблокирующий ввод/вывод.

// Неблокирующий ввод/вывод - это механизм при котором управление передается 
//      обратно в поток без ожидания завершения операций ввода/вывода. Шаблон 
//      "цикл ожидания" (busy­ waiting) является основным при реализации этого 
//      механизма, он включает опрос ресурса в цикле, пока тот не вернет данные.
//      Алгоритмы опроса ресурсов сильно загружают центральный процессор.

function NonblockingIO() {

    // ресурсы
    let socket = {}, pipe = {};
    let resources = [socket, pipe];

    // 
    while (resources.length !== 0) {
        for (i = 0; i < resources.length; i++) {
            let resource = resources[i];

            // попытка чтения
            let data = resource.read();

            // на данный момент нет данных для чтения
            if (data.isAvailable()) continue;

            // 
            if (data.isClose()) {
                // если ресурс закрыт, удаляем его из списка
                resources.remove(i);
            }
            else {
                // обработка данных
                consume(data);
            }
        }
    }
}

// --- 4.3 Демультиплексирование событий.

// Демультиплексирование событий - это механизм параллельной, неблокирующей работы 
//      с ресурсами. Этот подход основан на очереди событий, которая заполняется 
//      событиями от наблюдаемых ресурсов. Выполнение задач, связанных с вводом/выводом, 
//      распределяется по времени, а не по нескольким потокам. Преимуществом является 
//      сведение к минимуму времени простоя потока в ожидании готовности ресурсов 
//      ввода/вывода.

function Demultiplexing_Events() {

    //
    let demultiplexer = {
        watch: () => [],
        unwatch: f => f,
        consume: f => f,
    }

    // ресурсы
    let socket = {}, pipe = {};

    // ресурсы добавляются в структуру данных вместе с конкретными операциями
    const resources = new Map();
    resources.set(socket, { action: "read" });
    resources.set(pipe, { action: "read" });

    // цикл выполняет слежение за ресурсами и блокирует выполнение до готовности
    //      одного из наблюдаемых ресурсов, после чего возобновляет работу и
    //      обрабатывает новый набор событий
    while (events = demultiplexer.watch(resources)) {

        // цикл событий обрабатывает события ресурсов, возвращаемые демультиплексором,
        //      при этом выполнение не блокируется, так как ресурс гарантированно
        //      готов к чтению, после обработки всех событий поток блокируется
        //      демультиплексором в ожидании новой порции событий
        events.forEach(event => {

            // чтение нового блока с обязательным возвратом данных
            let data = event.resource.read();
            if (data.isClosed()) {
                // удалить ресурс из списка при его закрытии
                demultiplexer.unwatch(event.resource);
            }
            else {
                // обработать данные
                demultiplexer.consume(data);
            }
        });
    }
}

// --- 4.4 Шаблон Reactor.

// Существует два способа выполнения операций ввода/вывода:
//      Blocking I/O - код вызывающий функцию (синхронную) прерывает свое выполнение
//          пока функция не вернет результат;
//      Non-Blocking I/O - код вызывающий функцию (асинхронную) продолжит выполнение 
//          не дожидаясь результатов этой функции.

// Шаблон 'Reactor' используется, чтобы избежать блокировки операций ввода/вывода. 
//      Паттерн работает на основе демультиплексора и callback-обработчиков. 
//      Запросы ввода/вывода передаются демультиплексору, который собирает запросы 
//      в форме событий и направляет их в очередь, избегая при этом блокировки 
//      ввода/вывода.

//      ╔═════════════════════════════════════════════════════════════════════════════════════╗
//      ║                           ╭─────────────────────────────────────╮                   ║
//      ║                           |            Application              |                   ║
//      ║                      1    |   ┌──────────┐   5b   ┌─────────┐   |                   ║
//      ║                 ╭─────────────┤ Request  ├ ← ─────┤ Execute |   |                   ║
//      ║                 |     ╭┈┈┈┈ → ┤   I/O    ├┈┈┈┈┈ → ┤ Handler |   |                   ║
//      ║                 |     ┊   |   └──────────┘        └─┬─────┬─┘   |                   ║
//      ║                 ↓     ┊   ╰─────────────────────────┊─────↑─────╯                   ║
//      ║ ╭───────────────┴─────┴──────────────╮           5a ┊     | ╭─────────────────────╮ ║
//      ║ |        Event Demultiplexer         |     ╭┈┈┈┈┈┈┈┈╯  4  | |     Event Queue     | ║
//      ║ | ┌──────────┬───────────┬─────────┐ |     ┊     ╭────────╯ | ┌───────┬─────────┐ | ║
//      ║ | | Resource | Operation | Handler | |     ↓     |          | | Event | Handler | | ║
//      ║ | └──────────┴───────────┴─────────┘ |    ╭┴ ← ← ┴ ← ← ╮    | └───────┴─────────┘ | ║
//      ║ | ┌──────────┬───────────┬─────────┐ | 6  ↓            ↑ 3  | ┌───────┬─────────┐ | ║
//      ║ | | Resource | Operation | Handler | ├ ← ─┤ Event Loop ├ ← ─┤ | Event | Handler | | ║
//      ║ | └──────────┴───────────┴─────────┘ |    ↓            ↑    | └───────┴─────────┘ | ║
//      ║ | ┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐ |    ╰ →  →  →  → ╯    | ┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐ | ║
//      ║ | ┊                                ┊ |                      | ┊                 ┊ | ║
//      ║ | └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘ |                      | └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘ | ║
//      ║ ╰──────────────────┬─────────────────╯                      ╰──────────┬──────────╯ ║
//      ║                    |                             2                     ↑            ║
//      ║                    ╰───────────────────────────────────────────────────╯            ║
//      ╚═════════════════════════════════════════════════════════════════════════════════════╝
//       Application - приложение;                          Event - событие;
//       Event Demultiplexer - демультиплексор событий;     Resource - ресурс;
//       Event Loop - цикл событий;                         Operation - операция ввода-вывода;
//       Event Queue - очередь событий;                     Handler - обработчик;
//
//      1. Application генерирует Operation, отправляя запрос в Demultiplexer. Отправка 
//          запроса является неблокирующим вызовом и немедленно возвращает управление 
//          обратно в приложение. Application указывает Handler, который будет вызываться 
//          после завершения Operation. 
//      2. Когда набор Operation завершается, Demultiplexer помещает новые события 
//          в Event Queue.
//      3. Event Loop проходит по элементам Event Queue.
//      4. Для каждого Event вызывается соответствующий Handler.
//      5. Handler является частью кода Application. 
//      5a. Handler вернет управление в Event Loop, когда его выполнение завершится.
//      5b. Во время выполнения Handler могут быть запрошены новые асинхронные операции, 
//          в результате чего новые Operation будут направлены в Demultiplexer перед
//          возвратом управления в Event Loop.
//      6. Когда все элементы в Event Queue будут обработаны, Demultiplexer заблокирует 
//          Event Loop и затем запустит следующий Event Loop.

// Приложение NodeJS автоматически завершается, если в демультиплексоре не остается
//      отложенных операций и событий в очереди.

// Библиотека libuv обеспечивает совместимость NodeJS со всеми основными платформами и 
//      реализует неблокирующую модель для разных демультиплексоров. Эта бибилиотека
//      является низкоуровневым движком ввода/вывода платформы NodeJS. Она реализует
//      шаблон Reactor.

// libuv
//      http://nikhilm.github.io/uvbook/