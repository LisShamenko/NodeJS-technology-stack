const fs = require('fs');
const path = require('path');



// --------------- 2. Шаблон Revealing Module (Открытый модуль).

// Шаблон Revealing Module (Открытый модуль) решает проблему отсутствия пространств 
//      имен в JavaScript, когда объекты находятся в глобальной области видимости, 
//      тем самым засоряя ее. Каждый модуль должен запускаться в собственной области 
//      видимости, переменные определяются локально и не загрязняют глобального 
//      пространства имен.

// Модульная система NodeJS разработана на основе спецификации CommonJS. 

// пример создания моудля, содержимое функции помещается в файл
function create_simple_module() {

    // самовызывающаяся функция создает ограниченную область видимости
    const module = (() => {
        const privateFoo = () => { };
        const privateBar = [];
        // экспортируется только то что необходимо
        const exported = {
            publicFoo: () => { },
            publicBar: () => { }
        };
        return exported;
    })();

    console.log(`--- ограничение области видимости --- ${module}`);
}

// загрузка модуля
function loadModule(filename, module, require) {

    // исходный код модуля загружается из файла, заключается в самовызывающуюся 
    //      функцию, которая передает модулю переменные: module, exports, require
    const wrappedSrc = `
        (function(module, exports, require) {
            ${fs.readFileSync(filename, 'utf8')}
        })(module, module.exports, require);
    `;

    // функция eval выполняет код модуля представленный прип помощи обычной строки
    eval(wrappedSrc);

    // функция eval и функции модуля vm делает систему уязвимой для атак посредством 
    //      внедрения кода, использовать их следует с осторожностью или просто 
    //      отказаться от них
    //      https://nodejs.org/api/vm.html
}

// имитация оригинальной функции require
const _require = (moduleName) => {
    console.log(`--- функция require вызвана для модуля: ${moduleName}`);

    // функция resolve реализует алгоритм поиска модуля и возвращает идентификатор 
    //      модуля, который зависит от размещения файла, так модули с одинаковыми 
    //      именами могут размещаться в разных каталогах и не вызывать конфликтов
    const id = _require.resolve(moduleName);

    // проверка кэша, если модуль уже загружен, то он возвращается немедленно из кэша
    if (_require.cache[id]) {
        return _require.cache[id].exports;
    }

    // метаданные модуля, при первой загрузке модуля создается объект модуля, который 
    //      помещается в кэш, через этот объект вызывающий код получает доступ к модулю
    const module = {
        exports: {}, id: id
    };

    // объект модуля сохраняется в кэше
    _require.cache[id] = module;

    // код модуля читается из файла и выполняется, после чего связывается с объектом 
    //      модуля из кэша и получает ссылку на функцию require, затем модуль 
    //      экспортирует свой общедоступный интерфейс, изменяя или подменяя объект 
    //      module.exports
    loadModule(id, module, _require);

    // общедоступный интерфейс модуля, сохраненный в module.exports, возвращается 
    //      вызывающему коду
    return module.exports;
};

// хранилище кэша
_require.cache = {};

// извлечение идентификатора модуля по имени модуля
_require.resolve = (moduleName) => {

    return path.join(__dirname, moduleName);

    //switch (moduleName) {
    //    case './PatternRevealingModule/first': return 1;
    //    case './PatternRevealingModule/second': return 2;
    //    case './PatternRevealingModule/patternNamedExports': return 3;
    //    case './PatternRevealingModule/patternExportingFunction': return 4;
    //    case './PatternRevealingModule/patternExportingConstructor': return 5;
    //    case './PatternRevealingModule/patternExportingInstance': return 6;
    //    case './PatternRevealingModule/patternMonkeyPatching': return 7;
    //    default: return 0;
    //}
};

// --- 2.1 Переменная global.

// Система модулей экспортирует переменную global, которая позволяет размещать 
//      объекты в глобальной области видимости. Но это обесценивает преимущества 
//      системы модулей и считается плохой практикой, поэтому данную возможность 
//      следует использовать, когда это действительно необходимо.

// --- 2.2 Разница между module.exports и exports.

function module_exports_and_exports() {

    // переменная exports является ссылкой на начальное значение module.exports
    exports.hello = () => console.log('--- hello ---');

    // если присвоить переменной exports новое значение, то это не повлияет 
    //      на module.exports, и сама переменная exports перестанет указывать 
    //      на module.exports
    exports = () => console.log('--- hello ---');

    // переопределение свойства hello не имеет смысла, exports указывает на новый 
    //      объект, а не на module.exports
    exports.hello = "Hello!";

    // изначально в module.exports находится пустой объект, если необходимо 
    //      экспортировать, что то кроме объекта, то следует присвоить это напрямую 
    //      переменной module.exports
    module.exports = () => console.log('--- hello ---');
}

// --- 2.3 Синхронность require.

// Оригинальная функция require является синхронной и любое присваивание переменной 
//      module.exports должно выполняться синхронно. Синхронный подход к загрузке 
//      модулей является более надежным решением, чем асинхронная загрузка. 
//      Асинхронная загрузка модуля не гарантирует его готовность к использованию 
//      в другом модуле в качестве зависимости. 

// Непраильный код:
//
//      setTimeout(() => {
//          module.exports = function () { };
//      }, 100);

// --- 2.4 Алгоритм разрешения зависимостей.

// "Ад зависимостей" - это ситуация, когда разным модулям требуется одна общая 
//      зависимость разных несовместимых версий. Проблема решается загрузкой 
//      нужной версии модуля из разных каталогов при помощи npm и алгоритма 
//      разрешения зависимостей в require. Алгоритм по имени модуля возвращает 
//      путь к модулю, который становится идентификатором модуля. 

// Алгоритм разрешения зависимостей:
// - Модули в файлах:
//      если имя модуля начинается с '/', то оно считается абсолютным путем и 
//          возвращается как есть; 
//      если имя модуля начинается с './', то оно считается относительным путем и 
//          расчитывается относительно каталога загружающего модуля.
// - Модули ядра: 
//      если имя модуляне начинается с '/' или './', то выполняется поиск модуля 
//          ядра NodeJS.
// - Модули в пакетах: 
//      если модуль не был найден в ядре, то поиск продолжается в каталогах 
//          node_modules, начиная с родительской папки и заканчивая корневым 
//          каталогом системы

// Более точное описание алгоритма разрешения зависимостей:
//      http://nodejs.org/api/modules.html#modules_all_together

// Все зависимости npm помещает в каталог node_modules. У каждой зависимости может 
//      быть собственный каталог node_modules со своими версиями зависимостей.

//  myApp
//  ├── foo.js                      require('depA') загрузит "/myApp/node_modules/depA/index.js"
//  └── node_modules
//      ├── depA
//      │   └── index.js
//      ├── depB
//      │   ├── bar.js              require('depA') загрузит "/myApp/node_modules/depB/node_modules/depA/index.js"
//      │   └── node_modules
//      │   └── depA
//      │       └── index.js
//      └── depC
//          ├── baz.js           require('depA') загрузит "/myApp/node_modules/depC/node_modules/depA/index.js"
//          └── node_modules
//              └── depA
//                  └── index.js

// --- 2.5 Кэширование модулей.

// Функция require кэширует модули. Преимущества кэширования:
//      - лучшая производительность;
//      - позволяет иметь циклические зависимости модулей;
//      - гарантирует использование одного экземпляра во всем приложении.

// Удалить модуль из кэша можно через коллекцию require.cache удалив ключ модуля. 
//      Данный метод не рекомендуется использовать в реальных приложениях, только 
//      для тестирования.

// --- 2.6 Циклические зависимости.

// попытка загрузить модули с циклическими зависимостями
function load_cross_require() {
    const first = _require('./PatternRevealingModule/first.js');
    const second = _require('./PatternRevealingModule/second.js');

    // модуль second загружается не правильно, так как в момент его загрузки 
    //      модуль first еще не зугражен
    console.log(first);             // { secondWasLoaded: true, loaded: true }
    console.log(second);            // { firstWasLoaded: false, loaded: true }
}

// --- 2.7 Шаблоны определения модулей.

// Система модулей является, как механизмом загрузки зависисмостей, так и 
//      инструментом определения программных интерфейсов.

// Система модулей поощряет следование принципу единственной ответственности (Single 
//      Responsibility Principle, SRP): каждый модуль должен отвечать только за одну 
//      ответственность, которая должна быть полностью реализована этим модулем.

// Основным фактором при проектировании является баланс между закрытой и открытой 
//      функциональностью. Цель заключается в достижении наибольшего удобства 
//      использования кода при максимальном сокрытии информации, с учетом 
//      расширяемости и повторного использования.

// --- --- Шаблон: именованный экспорт.

// Шаблон именованный экспорт - в этом шаблоне все переменные и функции, которые 
//      должны быть общедостыпными, помещаются в один экспортируемый объект. Этот 
//      объект можно рассматривать, как контейнер или пространство имен. 

const patternNamedExports = _require('./PatternRevealingModule/patternNamedExports.js');
patternNamedExports.info('This is an informational message');
patternNamedExports.verbose('This is a verbose message');

// --- --- Шаблон: экспорт функций (Substack).

// Шаблон экспорт функций (substack): основные функциональные возможности модуля 
//      экспортируются в виде одной единственной функции, которая должна использоваться 
//      как пространство имен для прочих вспомогательных возможностей. Такой модуль 
//      имеет одну точку входа, что упрощает его понимание и использование. Это также 
//      соответствует принципу небольшой общедоступной области. Шаблон Substack назван 
//      в честь Джеймса Халлидея.

const patternExportingFunction = _require('./PatternRevealingModule/patternExportingFunction.js');
patternExportingFunction('This is an informational message');
patternExportingFunction.verbose('This is a verbose message');

// --- --- Шаблон: экспорт конструктора.

// Шаблон экспорт конструктора - этот шаблон позволяет создавать экземпляры модуля 
//      с помощью конструктора, а так же расширять прототип модуля, чтобы создать 
//      новые классы. Этот шаблон похож на экспорт функций тем, что обеспечивается 
//      одна точка входа в модуль, но предоставляются более широкие возможности 
//      расширения.

const patternExportingConstructor = _require('./PatternRevealingModule/patternExportingConstructor.js');
const dbLogger = new patternExportingConstructor('DB');
dbLogger.info('This is an informational message');

// В качестве расширения можно предоставлять защиту от использования моудля 
//      без ключевого слова new, что превращает модуль в фабрику.

const accessLogger = patternExportingConstructor('ACCESS');
accessLogger.verbose('This is a verbose message');

// --- --- Шаблон: экспорт экземпляра.

// Шаблон экспорт экземпляра - в этом шаблоне механизм кэширования модулей в require 
//      применяется для создания готового экземпляра через фабрику или конструктор. 
//      Этот экземпляр будет использоваться всеми, имортирующими его, модулями. 
//      В отличие от шаблона одиночки (singleton), не гарантируется уникальность 
//      экземпляра во всем приложении.

const patternExportingInstance = _require('./PatternRevealingModule/patternExportingInstance.js');
patternExportingInstance.log('This is an informational message');

// В качестве расширения шаблона можно экспортировать экземпляр и конструктор, 
//      что дает возможность расширять функционал и создавать новые экземпляры.

const customLogger = new patternExportingInstance.Logger('CUSTOM');
customLogger.log('This is an informational message');

// --- --- Шаблон: партизанское латание (monkey patching).

// Шаблон: партизанское латание (monkey patching) - изменение или расширение 
//      существующих объектов во время выполнения. Модуль может изменять глобальное 
//      пространство и любые объекты, включая другие кэшированные модули. Эта методика 
//      считается опасной. Изменение глобального пространства имен и других модулей 
//      может привести к не предсказуемым последствиям. Например, если два патча 
//      попытаются одновременно поменять свойство объекта, то нельзя будет определить 
//      чьи изменения будут последними. И самое главное, что это повлияет на работу 
//      всего приложения.

_require('./PatternRevealingModule/patternMonkeyPatching.js');
patternExportingInstance.customMessage();

// --- Запуск.

create_simple_module();
module_exports_and_exports();
load_cross_require();