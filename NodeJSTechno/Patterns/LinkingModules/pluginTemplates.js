// --------------- 3. Связывание плагинов.

// express     (http://expressjs.com) 
// gulp        (http://gulpjs.com) 
// grunt       (http://gruntjs.com)
// nodebb      (http://nodebb.org)
// docpad      (http://docpad.org)

// IoC от Мартина Фаулера (Martin Fowler)
//      http://martinfowler.com/bliki/InversionOfControl.html

// --------------- 3.1 Шаблон 'npm-плагин'.

// Шаблон 'npm-плагин' - шаблон основан на использовании npm пакетов 
//      как средства организации приложения. Пакеты создаются для достаточно 
//      больших функциональных частей приложения и помещаются в каталог 
//      node_modules. 

// Это дает ряд преимуществ:
// - убирает из проекта громоздкие относительные ссылки на локальные модули;
// - улучшается повторное использование; 
// - дает возможность управлять зависимостями плагина через npm. У плагина 
//      появляется собственный граф зависимостей, что снижает вероятность 
//      конфликтов между зависимостями, поскольку плагин не использует 
//      зависимости родительского проекта.

// Недостатком является: 
// - необходимость предоставления плагинам доступа к частям основного приложения.

// Существуют два подхода к расширению компонентов приложения:
// - Явное расширение. Конкретный компонент сам реализует новые функциональные 
//      возможности. Плагин сам вторгается в компоненты приложения для их 
//      расширения.
// - Инверсия управления (Inversion of Control, IoC). Инфраструктура управляет 
//      расширением и устанавливает новые компоненты. Управление находится 
//      в руках приложения, которое подключает плагин к одной из своих точек 
//      расширения.

// Точки расширения - это средства, которые применяются для подключения новых 
//      или изменения существующих функциональных возможностей приложения. 
//      Прокси и декоратор позволяют изменять или расширять функциональные 
//      возможности служб; стратегия меняет части алгоритмов; промежуточное ПО 
//      позволяет вставлять в конвейеры новые блоки обработки. Потоки данных 
//      способны обеспечить расширяемость благодаря их композиционной природе.
//      Наблюдатель реализованный через генератор событий позволяют ослабить 
//      связь между компонентами.

// Расширение, управляемое плагином. Открывает доступ к внутренним компонентам 
//      приложения и дает больше свободы, что увеличивает ответственность 
//      за внесение изменениий. Так любое изменение приложения может повлиять 
//      на плагин, что требует постоянного его обновления по мере развития 
//      основного приложения. Важное значение приобретает возможность совместного
//      использования внутренних служб приложения, иначе их просто не получится 
//      расширить.
// 
//      // в приложении
//      const app = express();
//      require('thePlugin')(app);
// 
//      // в плагине
//      module.exports = function plugin(app) {
//          app.get('/newRoute', function (req, res) { })
//      };

// Расширение, управляемое приложением. Требует создания инфраструктуры управления 
//      плагинами в приложении. Плагинам может потребоваться доступ к внутренним 
//      службам приложения, не для их модификации, а для использования. Например, 
//      доступ к базе.
// 
//      // в приложении
//      const app = express();
//      const plugin = require('thePlugin')();
//      app[plugin.method](plugin.route, plugin.handler);
//
//      // в плагине
//      module.exports = function plugin() {
//          return {
//              method: 'get',
//              route: '/newRoute',
//              handler: function (req, res) { }
//          }
//      }

// --------------- 3.2 Доступ к службам с использованием жестких зависимостей

// В этом варианте используются жесткие зависимости для связывания плагина 
//      с приложением. Плагину потребуется доступ к родительскому пакету, чтобы 
//      пользоваться службами основного приложения. Реализовать это можно двумя 
//      путями. 
//      - Использовать require на стороне плагина, но пакету должен быть известен 
//          путь к приложению. 
//      - Шаблон маскировки. Использовать require на стороне приложения при создании 
//          экземпляра плагина. Это даст плагину доступ к службам приложения через 
//          метод require. Этот вариант не зависит от каталога, где загружается 
//          пакет. Прием позволяет с минимальными усилиями организовать доступ 
//          к службам основного приложения, создает сильную связь с экземпляром 
//          службы и ее местоположением, что может привести к нарушению работы 
//          плагина при изменении связанной с ним службы.

// nodebb-plugin-poll - использование шаблона маскировки
//      https://github.com/NodeBB/nodebb-plugin-poll/tree/b4a46561aff279e19c23b7c635fda5037c534b84/lib
// nodebb-plugin-mentions - использование шаблона маскировки
//      https://github.com/julianlam/nodebb-plugin-mentions/blob/9638118fa7e06a05ceb24eb521427440abd0dd8a/library.js#L4-13

// Запуск:
//      node app
// Получение нового маркера:
//      curl -X POST -d '{"username": "alice", "password":"secret"}' http://localhost:3000/login -H "Content-Type: application/json"
// Проверка маркера:
//      curl -X GET -H "Accept: application/json" http://localhost:3000/checkToken?token=<TOKEN HERE>
// Инвалидация маркера:
//      curl -X GET -H "Accept: application/json" http://localhost:3000/logout?token=<TOKEN HERE>

// --------------- 3.3 Доступ к службам с использованием локатора служб

// Локатор служб позволяет, как приложению предоставить доступ к своим внутренним
//      службам, так и плагину открыть доступ к своим службам для приложения или
//      даже для других плагинов, что является наиболее важной причиной использования 
//      этого шаблона в контексте расширения, управляемого плагинами.

// --------------- 3.4 Доступ к службам с использованием DI

// Этот шаблон становится практически обязательным, если уже является основным 
//      методом подключения зависимостей в родительском приложении. Этот способ 
//      позволяет полностью контролировать доступ к службам и защищает приложение 
//      от чрезмерно агрессивных расширений. Но это может оказаться недостатком, 
//      если приложение не знает какие службы нужны плагину. В результате могут 
//      быть внедрены все службы или основная их часть.

// --------------- 3.5 Доступ к службам с использованием DI-контейнера

// Любой плагин получает доступ к любой службе приложения, что затрудняет сокрытие 
//      информации и контроль за использованием служб. Решением проблемы может стать 
//      создание дополнительного контейнера, в котором будут находится доступные 
//      для плагинов службы.