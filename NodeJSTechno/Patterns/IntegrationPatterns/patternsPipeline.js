// --------------- 42. Шаблоны конвейеров и распределения заданий.

// Шаблон ['Конкурирующие потребители', 'Разветвляющее распределение', 'Вентилятор'] - 
//      в этом шаблоне каждое сообщение должно отправляться только одному потребителю.
//      Не производитель подключается к потребителям, а потребители подключаются 
//      к производителю для получения новых заданий. Это большое преимущество 
//      для масштабируемой системы, позволяющее плавно увеличить число рабочих процессов 
//      без изменения производителя и без необходимости использовать реестр служб.

// В универсальной системе обмена сообщениями нет необходимости иметь связь вида 'запрос/ответ' 
//      между производителем и рабочими процессами. Вместо этого предпочтительнее использовать 
//      одностороннюю асинхронную связь, более пригодную для распараллеливания и масштабирования. 
//      В такой архитектуре сообщения всегда можно перемещать в одном направлении, создавая конвейеры.
//      Конвейеры позволяют создавать очень сложные архитектуры обработки без использования синхронных 
//      связей вида 'запрос/ответ', что обеспечивает высокую скорость и пропускную способность. 

//  ╔════════════════════════════════════════════════════════╗
//  ║                      ╭────╮     ╭────╮                 ║
//  ║                  ╭ → ┤узел├── → ┤узел├──╮              ║
//  ║ ╭─────────────╮  │   ╰────╯     ╰────╯  │   ╭────────╮ ║
//  ║ │распределение├──┤                      ├ → ┤приемник│ ║
//  ║ ╰─────────────╯  │   ╭────╮     ╭────╮  │   ╰────────╯ ║
//  ║                  ╰ → ┤узел├── → ┤узел├──╯              ║
//  ║                      ╰────╯     ╰────╯                 ║
//  ╠════════════════════════════════════════════════════════╣
//  ║ Архитектура с односторонней асинхронной связью         ║
//  ╚════════════════════════════════════════════════════════╝
// Распределение сообщений между множеством рабочих процессов и объединение в один узел.
//      Комбинацию конвейера с шаблоном распределения заданий часто называют 
//      параллельным конвейером.

// Два варианта реализации: с прямой передачей и передачей через брокера.

// --- 42.1 Шаблон распределения/слияния в ØMQ.

// Сокеты PUSH/PULL: 

// - Сокеты PUSH предназначены для отправки сообщений. Сокеты PULL предназначены 
//      для получения сообщений.

// - Оба сокета могут работать в режиме подключения или в режиме привязки. Сообщения всегда 
//      перемещаются в одном направлении, от сокета PUSH к сокету PULL, различными могут быть 
//      только инициаторы соединений. Режим привязки является лучшим решением надежных узлов, 
//      (поставщик заданий и приемник), режим подключения идеально подходит для промежуточных 
//      узлов (исполнители заданий). Это позволяет произвольно менять количество промежуточных 
//      узлов, не затрагивая более надежных узлов.

// - Если несколько сокетов PULL подключить к одному сокету PUSH, то сообщения равномерно 
//      распределяются по всем сокетам PULL, что обеспечивает одноранговое распределение нагрузки. 
//      Сокет PULL, принимающий сообщения от нескольких сокетов PUSH, будет обрабатывать сообщения 
//      с помощью справедливой системы очередей, то есть извлекать их равномерно из всех источников.

// - Сообщения, отправленные через сокет PUSH, который не имеет подключенных сокетов PULL, 
//      хранятся в очереди производителя, пока узел вновь не подключится и не начнет извлекать 
//      сообщения.

//      https://ru.wikipedia.org/wiki/Чрезвычайная_параллельность

//  ╔═════════════════════════════════════════════════════════════════════════════╗
//  ║                    ╭┄┄┄┄┄┄┄┄╮  ╭───────────╮  ╭┄┄┄┄┄┄┄┄╮                    ║
//  ║                    ┆       ╭┴──┴╮ рабочий ╭┴──┴╮       ┆                    ║
//  ║ ╭───────────────╮  ↓   ╭ → ┤pull│ процесс │push├──╮    ↓  ╭───────────────╮ ║
//  ║ │  генератор   ╭┴──┴╮  │   ╰────┴─────────┴────╯  │   ╭┴──┴╮   сборщик    │ ║
//  ║ │  вариантов   │push├──┤                          ├ → ┤push│ результатов  │ ║
//  ║ │ (вентилятор) ╰┬──┬╯  │   ╭────┬─────────┬────╮  │   ╰┬──┬╯  (приемник)  │ ║
//  ║ ╰───────────────╯  ↑   ╰ → ┤pull│ рабочий │push├──╯    ↑  ╰───────────────╯ ║
//  ║                    ┆       ╰┬──┬╯ процесс ╰┬──┬╯       ┆                    ║
//  ║                    ╰┄┄┄┄┄┄┄┄╯  ╰───────────╯  ╰┄┄┄┄┄┄┄┄╯                    ║
//  ╠════════════════════════════════════════════════╗      ───сообщение────      ║
//  ║ Архитектура с односторонней асинхронной связью ║      ┄┄┄соединение┄┄┄      ║
//  ╚════════════════════════════════════════════════╩════════════════════════════╝

// Вентилятор генерирует все возможные наборы символов заданного алфавита и передает их нескольким 
//      рабочим процессам, которые вычисляют хеш­сумму каждого варианта и проверяют ее соответствие 
//      заданной. Если совпадение найдено, результат передается узлу сборщика результатов (приемнику).

// Надежными узлами в этой архитектуре являются вентилятор и приемник, а переходными узлами являются
//      рабочие процессы. Каждый рабочий процесс подключает свой сокет PULL к вентилятору, а сокет PUSH 
//      к приемнику. Следуя этой схеме, можно запускать и останавливать сколько угодно рабочих процессов,
//      без перенастройки вентилятора и приемника.

// Запуск:
//      "variations-stream": "^0.1.3"
//      "zmq": "^2.14.0"
//      node worker
//      node worker
//      node sink
//      node ventilator 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b
//          запуск генератора

function require_421() {

    // 
    const { createSink } = require('./PatternsPipeline/a1_fanout_fanin/sink');
    const { createWorker } = require('./PatternsPipeline/a1_fanout_fanin/worker');
    const { createVentilator } = require('./PatternsPipeline/a1_fanout_fanin/ventilator');

    // 
    (async () => {

        // npm i deasync
        const toPort = '5017';
        const fromPort = '5016';
        const length = 4;
        const hash = 'c43a57ea3dd6a3758a5669ed5ca3f1bfe5dfa174'; // ihb

        // ошибка:
        //      bindSync() has been removed from compatibility mode; use bind() instead, or add 'deasync' to your project dependencies
        // решение:
        //      npm i deasync
        //          установка пакета deasync

        //
        await createWorker(fromPort, toPort);
        await createSink(toPort, () => {
            console.log(`
                --- complete --- 
            `);
            process.exit(0);
        });
        await createVentilator(fromPort, length, hash);
    })();
}

// --- 42.2 Конвейеры и конкурирующие потребители в AMQP.

// Сообщения не доставляются непосредственно получателям, если отправляются с помощью AMQP, а 
//      сначала попадают в коммутатор и уже затем в очередь. Затем брокер решает, куда направить
//      сообщение, основываясь на правилах в коммутаторе, привязках и очередях назначения.

//  ╔══════════════════════════════════════════════════════════════════════════════════════════════╗
//  ║                         ╭╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╮    ╭───────────────╮       ║
//  ║                         ╎              очередь заданий        ┌─┊─ → ┤рабочий процесс├ → ──╮ ║
//  ║ ╭───────────────────╮   ╎         ┌───┬───┬───┬───┬───┬───┐   │ ╎    ╰───────────────╯     │ ║
//  ║ │генератор вариантов├───┊────── → ┤   │   │   │▒▒▒│▒▒▒│▒▒▒├───┤ ╎                          │ ║
//  ║ │  (производитель)  │   ╎         └───┴───┴───┴───┴───┴───┘   │ ╎    ╭───────────────╮     │ ║
//  ║ ╰───────────────────╯   ╎ Брокер                              └─┊─ → ┤рабочий процесс├ → ──┤ ║
//  ║                         ╎            очередь результатов        ╎    ╰───────────────╯     │ ║
//  ║     ╭───────────╮       ╎         ┌───┬───┬───┬───┬───┬───┐     ╎                          │ ║
//  ║     │  сборщик  ├ ← ────┊─────────┤▒▒▒│   │   │   │   │   ├ ← ──┊──────────────────────────╯ ║
//  ║     │результатов│       ╎         └───┴───┴───┴───┴───┴───┘     ╎                            ║
//  ║     ╰───────────╯       ╰╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╯              ╔═════════════╣
//  ║                                                                                ║ Брокер AMQP ║
//  ╚════════════════════════════════════════════════════════════════════════════════╩═════════════╝
// Для распределения заданий между несколькими рабочими процессами следует использовать 
//      одну очередь (очередь заданий). На другом конце очереди находится группа рабочих 
//      процессов (конкурирующие потребители), каждый из которых будет извлекать разные 
//      сообщения из очереди, то есть несколько разных заданий будет выполняться параллельно 
//      в разных рабочих процессах. Результаты рабочих процессов публикуются в другой очереди
//      (очередь результатов), которая эквивалентна слиянию.

// - При реализации шаблонов конвейера и распределения заданий с помощью систем, подобных AMQP, 
//      следует гарантировать, что любое сообщение получит только один потребитель, но это 
//      невозможно, если к коммутатору может быть подключено несколько очередей. Решением 
//      является отправка сообщения непосредственно в очередь назначения, в обход коммутатора,
//      это позволит гарантировать, что сообщение попадет только в одну очередь. Этот шаблон 
//      связи называется точка-точка, или прямая передача.

// - Если одна очередь обслуживает несколько потребителей, сообщения между ними должны 
//      распределяться равномерно, путем реализации разветвляющего распределения. В контексте 
//      брокера сообщений это называется шаблоном конкурирующих потребителей.

// Запуск:
//      node worker
//      node worker
//      node collector
//      node producer 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b
//          запуск модуля сборщика и производителя

function require_422() {

    // 
    const { createWorker } = require('./PatternsPipeline/a2_competing_consumers/worker');
    const { createCollector } = require('./PatternsPipeline/a2_competing_consumers/collector');
    const { createProducer } = require('./PatternsPipeline/a2_competing_consumers/producer');

    // 
    (async () => {

        // 
        const length = 3;
        const hash = 'c43a57ea3dd6a3758a5669ed5ca3f1bfe5dfa174'; // ihb

        //
        await createWorker();
        await createWorker();
        await createCollector();
        await createProducer(length, hash);
    })();
}

// --- Запуск.

module.exports = (example) => {
    if (example === 42.1) require_421();
    if (example === 42.2) require_422();
}