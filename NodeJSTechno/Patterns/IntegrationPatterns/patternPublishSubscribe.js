// --------------- 41. Шаблон "Публикация/подписка".

//      ╔══════════════════════════════════╦═══════════════════════════════════════════╗
//      ║                      ╭─────────╮ ║                               ╭─────────╮ ║
//      ║                ╭── → ┤подписчик| ║                         ╭── → ┤подписчик| ║
//      ║                │     ╰─────────╯ ║                         │     ╰─────────╯ ║
//      ║ ╭────────╮     │     ╭─────────╮ ║  ╭────────╮   ╭──────╮  │     ╭─────────╮ ║
//      ║ │издатель├ → ──┼── → ┤подписчик| ║  │издатель├ → ┤брокер├──┼── → ┤подписчик| ║
//      ║ ╰────────╯     │     ╰─────────╯ ║  ╰────────╯   ╰──────╯  │     ╰─────────╯ ║
//      ║                │     ╭─────────╮ ║                         │     ╭─────────╮ ║
//      ║                ╰── → ┤подписчик| ║                         ╰── → ┤подписчик| ║
//      ╠═════════════════╗    ╰─────────╯ ╠═══════════════════════╗       ╰─────────╯ ║
//      ║ Прямая передача ║                ║ Передача через брокер ║                   ║
//      ╚═════════════════╩════════════════╩═══════════════════════╩═══════════════════╝

// Два варианта реализации шаблона 'Публикация/подписка': для прямого обмена сообщениями и 
//      с брокером в качестве посредника. Подписчики регистрируются на получение сообщений, 
//      что позволяет издателю работать с произвольным количеством получателей. Обе стороны 
//      слабо связаны друг с другом, что делает этот шаблон идеальным для интеграции узлов 
//      эволюционирующей распределенной системы. Брокер еще больше ослабляет связанность 
//      узлов системы, поскольку подписчики взаимодействуют только с брокером и ничего 
//      не знают об издателе.

// --- 41.1 Минимальное приложение для общения в режиме реального времени.

// ws - реализует поддержку веб­сокетов
//      https://npmjs.org/package/ws

// ecstatic
//      https://npmjs.org/package/ecstatic

// Запуск:
//      node app 8080
//      node app 8081
//      http://localhost:8081

function require_411() {

    // 
    const { createApp } = require('./PatternPublishSubscribe/expressApp');
    const { createServer } = require('./PatternPublishSubscribe/a1_basic_chat/app');

    // 
    (async () => {
        await createServer(8001, () => process.exit());
        await createApp('index.ejs', 8001, 8002);
        await createApp('index.ejs', 8001, 8003);
        await createApp('index.ejs', 8001, 8004);
    })();
}

// --- 41.2 Использование Redis в качестве брокера сообщений.

// Redis - сервер структур данных, хранилище пар ключ/значение. Из ­за скорости и 
//      гибкости Redis часто применяют в распределенных системах для совместного 
//      использования данных.
//      http://redis.io
//      http://redis.io/topics/quickstart

//      ╔═══════════════════════════════════╗
//      ║ ╭──────╮ 1 ╭──────╮ 2             ║
//      ║ |клиент├ → ┤сервер├───────────╮   ║
//      ║ |      ├ ← ┤ чата ├ ← ──╮     |   ║
//      ║ ╰──────╯ 4 ╰──────╯     |     |   ║
//      ║ ╭──────╮   ╭──────╮     |     ↓   ║
//      ║ |клиент|   |сервер|     | 3 ╭─┴─╮ ║
//      ║ |      ├ ← ┤ чата ├ ← ──┼───┤   | ║
//      ║ ╰──────╯ 4 ╰──────╯     |   ╰───╯ ║
//      ║ ╭──────╮   ╭──────╮     |         ║
//      ║ |клиент|   |сервер|     |         ║
//      ║ |      ├ ← ┤ чата ├ ← ──╯         ║
//      ║ ╰──────╯ 4 ╰──────╯               ║
//      ╠═════════════════╗                 ║
//      ║ Чат с брокерами ║                 ║
//      ╚═════════════════╩═════════════════╝
//      Все экземпляры публикуют сообщения в брокере и регистрируются как получатели 
//          сообщений, поступающие от других экземпляров:
//      1 - сообщение вводится в текстовое поле и отправляется экземпляру сервера чата;
//      2 - сервер публикует сообщение в брокере;
//      3 - брокер рассылает сообщение всем экземплярам сервера чата;
//      4 - каждый экземпляр рассылает полученное сообщение своим клиентам.

// Сервер Redis позволяет публиковать каналы и подписываться на каналы со строковым 
//      идентификатором, а также позволяет использовать глобальные шаблоны для определения 
//      подписок, охватывающих несколько каналов.

// Команды Redis реализуют механизм QoS0, но Redis можно использовать для реализации 
//      надежной подписки:
//      http://davidmarquis.wordpress.com/2013/01/03/reliable-delivery-message-queues-with-redis
//      http://www.ericjperry.com/redis-message-queue

// Запуск:
//      node app 8080
//      node app 8081
//      node app 8082

function require_412() {

    // 
    const { createApp } = require('./PatternPublishSubscribe/expressApp');
    const { createServer } = require('./PatternPublishSubscribe/a2_chat_redis/app');

    // 
    (async () => {
        await createServer(8001, () => process.exit());
        await createApp('index.ejs', 8001, 8002);
        await createApp('index.ejs', 8001, 8003);
        await createApp('index.ejs', 8001, 8004);
    })();
}

// --- 41.3 Прямая публикация/подписка с помощью библиотеки ØMQ.

// ØMQ (zmq, ZeroMQ, 0MQ) - низкоуровневая и очень быстрая библиотека для создания 
//      систем обмена сообщениями: атомарные сообщения, распределение нагрузки, 
//      очереди и прочее. Поддерживает многие виды транспортировки: каналы внутри 
//      процесса (inproc://), средства связи между процессами (ipc://), многоадресную 
//      рассылку по протоколу PGM (pgm:// или epgm://), классический протокол TCP (tcp://).
//      http://zeromq.org
//      http://zeromq.org/intro:get-the-software

// Имеются два специальных типа сокетов: PUB и SUB. Сокет PUB обычно подключается 
//      к порту, на который поступают подписки из других сокетов SUB. Подписка может 
//      иметь фильтр, определяющий, какие сообщения должны доставляться в сокет SUB. 
//      Фильтр - это просто двоичный буфер (или строка), содержимое которого будет 
//      сравниваться с началом сообщения (двоичным буфером). При отправке сообщения 
//      через сокет PUB оно передается во все подключенные сокеты SUB после применения 
//      их фильтров подписки. Фильтры применяются на стороне издателя и только если 
//      используется протокол с поддержкой постоянных соединений, такой как TCP.

// ØMQ имеет механизм повторного подключения. Если порт PUB окажется недоступен, 
//      то ØMQ будет пытаться установить соединение с ним через регулярные интервалы 
//      времени. Что удобно если требуется перезапустить узел. При отсутствии подписок 
//      сокет PUB будет удалять все сообщения и продолжит работу.

// Запуск трех экземпляров приложения, соединив их сокеты PUB и SUB:
//      node app --port 8080 --pub 5000 --sub 5001 --sub 5002
//          запускает экземпляр HTTP­ сервера, прослушивающий порт 8080, привязывает 
//          сокет PUB к порту 5000, сокет SUB к портам 5001 и 5002, которые должны 
//          прослушивать сокеты PUB других двух экземпляров
//      node app --port 8081 --pub 5001 --sub 5000 --sub 5002
//      node app --port 8082 --pub 5002 --sub 5000 --sub 5001

function require_413() {

    // Запуск ZMQ:
    //      node producer.js
    //      node worker.js

    // Проверка:
    //      process.argv = ['node.exe', 'app', '--port', '8080', '--pub', '5000', '--sub', '5001', '--sub', '5002'];
    //      require('./app');

    // запуск клиентов
    const { createApp } = require('./PatternPublishSubscribe/expressApp');
    (async () => {
        await createApp('index.ejs', 8080, 8002);
        await createApp('index.ejs', 8081, 8003);
        await createApp('index.ejs', 8082, 8004);
    })();
}

// --- 41.4 Надежная подписка

// Надежная подписка - это подписка, гарантирующая доставку всех сообщений, даже тех, 
//      что были отправлены, когда подписчик был отключен.

// Очередь сообщений (Message Queue, MQ). При наличии очереди сообщений отправителю и 
//      получателям сообщений необязательно быть одновременно активными, поскольку 
//      система очередей обеспечивает хранение сообщений, пока получатель не примет их. 
//      Эта модель поведения обратна парадигме 'отправил и забыл', в которой подписчик 
//      может получать сообщения, только когда он подключен к системе обмена сообщениями.

// Протокол MQTT определяет уровень качества обслуживания (Quality of Service, QoS) 
//      для сообщений, передаваемых между отправителем и получателем. 
// - QoS0, не более одного раза, 'послать и забыть': сообщение не сохраняется и 
//      доставка не подтверждается, сообщение может быть потеряно в случае сбоя или 
//      отключения получателя;
// - QoS1, не менее одного раза: сообщение гарантированно будет получено хотя бы 
//      один раз, но может быть продублировано, если получатель завершит работу 
//      из-за ошибки до того, как уведомит отправителя, сообщения сохраняются, 
//      только если возникает необходимость повторной отправки;
// - QoS2, строго один раз: гарантирует, что сообщение будет получено один и только 
//      один раз.
//      http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#qos-flows

// --- 41.5 Протокол AMQP.

// RabbitMQ 
//      https://www.rabbitmq.com/tutorials/amqp-concepts.html

//      ╔══════════════════════════════════════════════════════════════════════════════════════════════════╗
//      ║               ╭┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╮                     ║
//      ║               ┆ брокер                    ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆                     ║
//      ║               ┆    ╭────────────╮   ╭── → ┤фильтр├ → ┤   │   │   │   │▒▒▒├─┆─╮                   ║
//      ║ ╭────────╮    ┆    │ коммутатор │   │     ╰──────╯   └───┴───┴───┴───┴───┘ ┆ │       ╭─────────╮ ║
//      ║ │издатель├──┬─┆─ → ┤тематический├───┤                                      ┆ ├── → ┬─┤подписчик│ ║
//      ║ ╰────────╯  │ ┆    │ или прямой │   │     ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆ │     ↑ ╰─────────╯ ║
//      ║             │ ┆    ╰────────────╯   ╰── → ┤фильтр├ → ┤   │   │   │   │▒▒▒├─┆─┊─────┤             ║
//      ║             │ ┆                           ╰──────╯   └───┴───┴───┴───┴───┘ ┆ │     ↓ ╭─────────╮ ║
//      ║             │ ┆                                                            ┆ ╰── → ┴─┤подписчик│ ║
//      ║             │ ┆                           ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆         ╰─────────╯ ║
//      ║             │ ┆                     ╭── → ┤фильтр├ → ┤   │▒▒▒│▒▒▒│▒▒▒│▒▒▒├─┆───────╮             ║
//      ║             │ ┆    ╭─────────────╮  │     ╰──────╯   └───┴───┴───┴───┴───┘ ┆       ↓ ╭─────────╮ ║
//      ║ ╭────────╮  ╰─┆─ → ┤ коммутатор  ├──┤                                      ┆       ├─┤подписчик│ ║
//      ║ │издатель├────┆─ → ┤разветвляющий│  │     ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆       ↑ ╰─────────╯ ║
//      ║ ╰────────╯    ┆    ╰─────────────╯  ╰── → ┤фильтр├ → ┤   │   │▒▒▒│▒▒▒│▒▒▒├─┆───────╯             ║
//      ║               ┆                           ╰──────╯   └───┴───┴───┴───┴───┘ ┆              ╔══════╣
//      ║               ╰┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╯              ║ AMQP ║
//      ╚═══════════════════════════════════════════════════════════════════════════════════════════╩══════╝

// Протокол AMQP - открытый стандартный протокол, поддерживаемый многими системами 
//      сообщений с очередями, также он определяет модель для описания маршрутизации, 
//      фильтрации, организации очередей, надежности и безопасности. Содержит три 
//      компонента, которые создаются и управляются брокером: очередь, коммутатор, 
//      связь. Подключаясь к брокеру, клиент создает канал, чтобы поддерживать связь 
//      с брокером.

// Очередь: структура данных для хранения сообщений, которые передаются одному 
//      получателю или распределяются между несколькими получателями. Виды очередей:
//      - надежная очередь автоматически восстанавливается при перезапуске брокера, 
//          на диск будут сохранены только сообщения, отмеченные как хранимые, и 
//          будут восстановлены в случае перезагрузки;
//      - к эксклюзивной очереди может быть подключен только один конкретный подписчик, 
//          после закрытия соединения очередь уничтожается;
//      - автоматически удаляемая очередь удаляется после отключения последнего 
//          подписчика.

// Коммутатор: место публикации сообщений, направляет сообщения в одну или несколько 
//      очередей в зависимости от реализуемого алгоритма:
//      - прямое коммутирование, выбор маршрута определяется путем сопоставления 
//          полного ключа маршрутизации;
//      - тематическое коммутирование, выбор маршрута определяется путем сопоставления 
//          ключа с шаблоном;
//      - разветвляющее коммутирование, сообщения рассылаются во все подключенные 
//          очереди, независимо от ключа маршрутизации.

// Связь: между коммутаторами и очередями, определяет ключ маршрутизации или шаблон 
//      для фильтрации сообщений, поступающих от коммутатора.

// --- 41.6 Реализация надежной службы.

// RabbitMQ и AMQP
//      https://www.rabbitmq.com

//      ╔═══════════════════════════════════════════════════════════════════════════════════════════╗
//      ║ ╭───────────────────────────────────────────────────────────────────────────────────────╮ ║
//      ║ │  ╭┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╮ публикация сообщений │ ║
//      ║ │  ┆                                           chat_srv_8080     ┆  от клиентов         │ ║
//      ║ │  ┆                            ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆     ╭───────────╮    │ ║
//      ║ │  ┆  брокер              ╭── → ┤фильтр├ → ┤   │   │   │▒▒▒│▒▒▒├─┆── → ┤сервер чата├────┤ ║
//      ║ │  ┆                      │     ╰──────╯   └───┴───┴───┴───┴───┘ ┆     │(порт 8080)│    │ ║
//      ║ │  ┆     ╭─────────────╮  │                    chat_srv_8081     ┆     ╰───────────╯    │ ║
//      ║ │  ┆     │ коммутатор  │  │     ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆     ╭───────────╮    │ ║
//      ║ ╰──┆── → ┤разветвляющий├──┤── → ┤фильтр├ → ┤   │   │   │   │▒▒▒├─┆── → ┤сервер чата├────╯ ║
//      ║    ┆     │  ('chat')   │  │     ╰──────╯   └───┴───┴───┴───┴───┘ ┆     │(порт 8081)│      ║
//      ║    ┆     ╰─────────────╯  │                    chat_history      ┆     ╰───────────╯      ║
//      ║    ┆                      │     ╭──────╮   ┌───┬───┬───┬───┬───┐ ┆     ╭──────────────╮   ║
//      ║    ┆                      ╰── → ┤фильтр├ → ┤   │   │▒▒▒│▒▒▒│▒▒▒├─┆── → ┤служба истории│   ║
//      ║    ┆                            ╰──────╯   └───┴───┴───┴───┴───┘ ┆     ╰──────┬───────╯   ║
//      ║    ╰┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╯   ╭──╮     │           ║
//      ╠══════════════════════════╗                                           │DB├ ← ──╯           ║
//      ║ Чат с поддержкой истории ║                                           ╰──╯                 ║
//      ╚══════════════════════════╩════════════════════════════════════════════════════════════════╝
//      - серверы чата не являются надежными подписчиками и их очереди будут уничтожены 
//           при закрытии соединений (эксклюзивная очередь);
//      - служба истории должна быть надежной, чтобы все сообщения доставлялись независимо 
//           от ее состояния, сообщения сохраняются в базу данных, и любой клиент может
//           получить всю историю чата;

// amqplib - пакет LevelUP для подключения к RabbitMQ с использованием протокола AMQP
//      https://npmjs.org/package/amqplib
//      http://www.rabbitmq.com/download.html

// Запуск:
//      node app 8080
//      node app 8081
//      node historySvc
//      остановить службу истории

function require_416() {

    // 
    const { createApp } = require('./PatternPublishSubscribe/expressApp');
    const { createServer } = require('./PatternPublishSubscribe/a4_durable_sub/app');
    const { createHistoryServer } = require('./PatternPublishSubscribe/a4_durable_sub/historySvc');

    // 
    (async () => {
        await createServer(8080, 8090);
        await createServer(8081, 8090);
        await createHistoryServer(8090);
        await createApp('index.ejs', 8080, 8002);
        await createApp('index.ejs', 8081, 8003);
    })();
}

// --- Запуск.

module.exports = (example) => {
    if (example === 41.1) require_411();
    if (example === 41.2) require_412();
    if (example === 41.3) require_413();
    if (example === 41.6) require_416();
}