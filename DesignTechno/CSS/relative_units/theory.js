// доступ к пользовательским свойствам
function setCSSProperty() {

    console.log("--- setCSSProperty()");

    // эта техника позволяет применять JavaScript для изменения темы сайта, 
    //      выделять отдельные части страницы или вносить любые другие изменения 
    //      в реальном времени
    let rootElement = document.documentElement;
    console.log('--- --- rootElement = ', rootElement);

    // 
    let colorField = document.getElementById("color");
    let color = colorField.value;
    console.log('--- --- color = ', color);

    // 
    let darkPanel = document.getElementById("dark_panel");
    console.log('--- --- dark_panel = ', darkPanel);

    // получает объект styles для элемента
    let styles = getComputedStyle(darkPanel);
    console.log('--- --- styles = ', styles);

    // получает значение --main-background-color из объекта styles
    let mainColor = styles.getPropertyValue("--main-background-color");
    console.log('--- --- mainColor = ', mainColor);
    console.log('--- --- mainColor.trim() = ', String(mainColor).trim());

    // обновить переменную --main-background-color 
    let colorRegexp = /rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)/;
    let match = colorRegexp.exec(color);
    if (match != null) {
        console.log(`--- --- Red: ${match[1]} / Green: ${match[2]} / Blue: ${match[3]}`);
        darkPanel.style.setProperty("--main-background-color", color);
    }
    else {
        darkPanel.style.setProperty("--main-background-color", randomColor());
    }
}

// случайный цвет
function randomColor() {
    return 'rgb(' + random(0, 255) + ', ' + random(0, 255) + ', ' + random(0, 255) + ')';
}

// вернуть случайное целое
function random(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
}

// --------------- 2. Относительные единицы.

// Относительные единицы позволяют создавать адаптивные стили, которые определяют 
//      значения зависящие от разных факторов: размера окна браузера, размера шрифта 
//      родительского элемента или корневого элемента страницы.

// РЕКОМЕНДАЦИЯ:
//      - 1 дюйм = 25,4 мм = 2,54 см = 6 пик = 72 пункта = 96 пикселов 
//          (16 пикселов = 12 пунктов);
//      - rem для размера шрифта, размеры шрифта оказываются предсказуемыми, 
//          но сохраняются возможности em;
//      - px для ширины границ;
//      - em для большинства других свойств: отступы, поля, радиус скругления границ;
//      - % для определения ширины контейнеров, когда это необходимо;

// --- 2.1 Единицы em.

// Значение 1em соответствует размеру шрифта элемента к которому применяется стиль;

// Единицы em удобно использовать при настройке свойств [padding, height, width, 
//      border-radius], которые будут масштабироваться равномерно с элементом 
//      при изменении размера шрифта элемента;

// --- 2.2 Сжатие шрифтов.

// При множественном вложении элементов может возникнуть ситуация поступенчатого 
//      увеличения шрифта, если размеры шрифтов заданы в em единицах.

//      body {
//          font-size: 16рх;
//      }
//      ul {
//          font-size: 0.8em;
//      }
//      <ul>
//          <li> первый уровень, шрифт: 16px * 0.8
//              <ul> 
//                  <li> второй уровень, шрифт: 16px * 0.8 * 0.8
//                      <ul> 
//                          <li> третий уровень, шрифт: 16px * 0.8 * 0.8 * 0.8

// --- 2.3 Размер шрифта в единицах rem.

// Браузер создает в памяти представление всех элементов на странице в виде DOM 
//      (Document Object Model - объектная модель документа), которая представляет
//      собой древовидную структуру. Элемент html является предком всех элементов
//      документа и называется корневым узлом, для его назначения используется
//      селектор псевдокласса ':root', что эквивалентно селектору типа html со 
//      специфичностью класса, а не тега.

// rem - это сокращение от 'root em' (корневой em), единицы rem всегда относительны 
//      по отношению к корневому элементу и вычисляются от размера шрифта корневого 
//      элемента.

// --- 2.4 Антишаблон: глобальный сброс значения свойства font-size до 10 пикселов.

// Антишаблон заключается в установке шрифта корневого элемента (html) равным
//      по умолчанию 10px. Размер шрифта браузера по умолчанию 16px, чтобы сбросить
//      это значение до 10px следует задать размер 0.625em (62.5%). Это дает 
//      возможность задать размер шрифта элемента относительно 10. Например, 
//      чтобы получить шрифт 14px слеудет разделить 14 на 10 и задать значение 
//      в 1.4rem. Значение будет задано в относительных единицах но с пиксельным 
//      мышлением.

//      html {
//          font-size: .625em;
//      }
//      p {
//          font-size: 1.4rem;
//      }

// Антишаблон приводит к следующим проблемам: 
//      - приходится писать много повторяющихся стилей, так как 10px слишком мало 
//          для текста;
//      - пиксельное мышление, что мешает адаптивному дизайну: неважно чему равны 
//          1.2em это просто немного больше наследуемого шрифта;

// Следует установить базовый размер шрифта и несколько общих размеров для заголовков и 
//      сносок, абсолютные значения легче использовать при обсуждении размера объектов.

// --- 2.5 Адаптивная панель.

// Медиазапрос - это правило @media, задает стили, которые будут применяться только 
//      к определенным размерам экрана или типам устройств, что явялется ключевым 
//      компонентом адаптивного дизайна.

// РЕКОМЕНДАЦИЯ:
//      два медиазапроса в верхней части таблицы стилей могут избавить от необходимости 
//      делать десятки медиазапросов в остальной части CSS-кода, что не работает 
//      с пиксельными размерами.

// --- 2.6 Единицы: vh, vw, vmin, vmax.

// Спецификация:
//      https://www.w3.org/TR/css3-values/#viewport-relative-lengths

// Viewport (область просмотра) - это часть окна браузера в которой отображается 
//      веб-страница.

// Следующие единицы измерения, выражаются относительно размеров окна просмотра:
// - vh     1% высоты Viewport (50vw = 50% ширины Viewport)
// - vw     1% ширины Viewport (25vh = 25% высоты Viewport)
// - vmin   минимальный размер окна просмотра, наименьшее значение: vw или vh
// - vmax   максимальный размера окна просмотра, наибольшее значение: vw или vh

// Устанавливает высоту элемента в 90% от высоты окна браузера.
//      .modal {
//          height: 90vh;
//      }

// Единица vw размещает элемент точно в области просмотра независимо от альбомной или 
//      портретной ориентации.

// Для объявления 'font-size: 2vw' элемент будет без проблем масштабироваться между 
//      двумя размерами, но будет остутствовать контроль за крайними значениями, 
//      увеличение до 24px, что слишком много, а на iPhone 6 уменьшение до 7.5px, 
//      что слишком мало:
//      - при ширине монитора 1200px элемент равен 24px (2 % от 1200)
//      - при ширине монитора 768px элемент равен 15px (2 % от 768)

// Свойства line-height, z-index и font-weight поддерживают значения без указания 
//      единиц измерения.

// Эти единицы измерения полезно применять в сочетании с шрифтовыми настройками. 
//      Создает текст размером 25% от ширины окна просмотра.
//      .Hero-text {
//          font-size: 25vw;
//      }

// РЕКОМЕНДАЦИЯ:
//      значения без единиц измерения наследуются дочерними элементами без изменений, 
//      что всегда дает ожидаемый результат, если задать высоту строки для элемента 
//      body, то не придется устанавливать высоту в остальной части страницы.

// --- --- функция clamp

// Спецификация:
//      https://www.w3.org/TR/css-values-4/#calc-notation

// Функция clamp позволяет указывать минимальный, максимальный и переменный размеры. 
//      Размер шрифта ориентируется на 40% от ширины области просмотра, но 
//      не меньше 20px и не больше 80px.
//      .headline {
//          font-size: clamp (20px, 40vw, 80px)
//      }

// --- --- функция calc

// Функция calc позволяет вычислять выражение, состоящее из разных единиц 
//      измерения. Отнять точно 10px от половины ширины родительского элемента.
//      Поддерживаются: сложение, вычитание, деление, умножение.
//      .thing {
//          /* знак операции должен быть окружен пробелами */
//          width: calc(50% - 10px);
//      }

// --- 2.7 Пользовательские свойства CSS.

// Пользовательские свойства CSS позволяют хранить в таблицах стилей 
//      информацию, которая затем может использоваться в стилях. 

// Объявления пользовательских свойств каскадируются и наследуются: если 
//      определить одну и ту же переменную внутри нескольких селекторов, 
//      она будет иметь различные значения для разных частей страницы.

// Свойство --MainFont сохраняет семейства шрифтов. 
//      :root {
//          --MainFont: 'Helvetica Neue', Helvetica, Arial, sans-serif;
//      }

// Для сохранения пользовательского свойства в корне документа используется 
//      псевдокласс :root, который всегда ссылается на самый верхний 
//      родительский элемент. В HTML-документе псевдокласс :root ссылается
//      на элемент html. 

// Использовать пользовательское свойство можно с помощью записи var().
//      .Title {
//          font-family: var(--MainFont);
//      }

// Можно хранить любое количество пользовательских свойств. 
//      body {
//          background-color: var(--background);
//          color: var(--foreground);
//      }

// Доступ к пользовательским свойствам из кода JavaScript:
//      let root = document.documentElement;
//      let styles = getComputedStyle(root);
//      let bg = styles.getPropertyValue('--background');
//      root.style.setProperty('--background', bg === "#333" ? "#eee" : "#333");


// Пользовательские свойства ведут себя так же, как и другие свойства, с точки
//      зрения специфичности. Повторное объявление пользовательского свойства
//      переопределит предыдущее объявление свойства.
//      :root {
//          --backgroundColor: red;
//      }
//      header {
//          --backgroundColor: goldenrod;
//      }

// Ключевое слово var допускает определить значение по умолчанию, которое
//      будет использовано, если указанное пользовательское свойство 
//      отсутствует.
//      .my-Item {
//          background-color: var(--backgroundColor, #555);
//      }

// --- --- переменные среды

// Спецификация:
//      https://drafts.csswg.org/css-env-1/#env-function

// Некоторые переменные среды могут быть считаны при помощи функции env().
//      Единственный известный пример - это свойство 'safe-area-inset', которое
//      возвращает размер 'безопасной области' на смартфонах. 'Безопасная область'
//      называется раздел в верхней и нижней частях экрана, где области UI 
//      смартфона сталкиваются с областью просмотра.

// Добавить отступ к верхней части элемента, равный высоте 'безопасной области'.
//      padding-top: env(safe-area-inset-top);