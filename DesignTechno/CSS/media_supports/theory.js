// --------------- 18. Правила @media и @supports.

// --- 18.1 Метатег viewport.

// Областью просмотра (Viewport) - это область окна браузера, в которой отображается 
//      страница.

// Метатег viewport уведомляет мобильный браузер о наличиии макета для небольших 
//      экранов. Добавляется в тег <head> и указывает определенную ширину или 
//      множитель масштаба. Метатег viewport делает вид и поведение веб-дизайна 
//      предсказуемым! 

// Для большинства случаев отзывчивого дизайна подойдет этот вариант.
//      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

// Атрибут name со значением 'viewport' указывает, что это метатег viewport. 

// Атрибут content:
//      - значение 'initialscale=2.0' указывает, что размер страницы должен быть
//          увеличен в два раза;
//      - значение 'width=device-width' указывает браузеру, что ширина страницы 
//          должна быть равна значению device-width - ширине экрана устройства;
//      - значения maximum-scale и minimum-scale ограничивают масштабирование 
//          страницы;
//      - значение 'user-scalable=no' отключает масштабирование, в том числе 
//          запрещает масштабирование 'двумя пальцами', что не рекомендуется, 
//          поскольку нельзя будет рассмотреть изображение или увеличить ссылку;

// Вывод страницы в двойном масштабе.
//      <meta name="viewport" content="initial-scale=2.0, width=device-width"/>

// Метатег viewport может ограничить масштабирование страницы с помощью значений
//      maximum-scale и minimum-scale. Ограничить изменение масштаба от 50% до 300%.
//      <meta name="viewport" content="width=device-width, minimum-scale=0.5, maximum-scale=3" />

// Метатег viewport может отключить масштабирование с помощью значения user-scalable. 
//      Эта возможность применяется редко, поскольку масштабирование является важным 
//      средством для повышения удобства просмотра, поэтому многие браузеры игнорируют
//      эту настройку.
//      <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>

// --- 18.2 Медиазапросы.

// Спецификация:
//      https://www.w3.org/TR/mediaqueries-3/

// Медиазапросы определяют стили применяемые при определенных условиях, что позволяет 
//      адаптировать стили под разные устройства. Правило @media включает тип среды и 
//      несколько условных выражений для проверки медиасвойств. CSS стили внутри 
//      фигурных скобок подчиняются обычным правилам каскадности, а сам медиазапрос 
//      не влияет на специфичность селекторов.

// Медиазапросы можно разместить в одном файле CSS или загружать в медиазапросы 
//      целые таблицы стилей при помощи CSS-правил @import.

// Медиазапрос в элементе <link>.
//      <link rel="stylesheet" href="portrait-screen.css"
//          media="screen and (orientation: portrait)" />

// Правило @import позволяет загрузить файл с медиазапросами. Это правило заставляет 
//      браузер делать дополнительный HTTP-запрос для получения файла медиазапроса, 
//      что может сказаться на скорости загрузки сайта.
//      @import url("portrait-screen.css") screen and (orientation: portrait);

// Медиазапрос в файле CSS или внутри тега style.
//      @media screen and (orientation: portrait) { ... }

// --- 18.3 Синтаксис медиазапроса.

// Медиазпрос состоит из ключевого слова @media и тестов.

// Фоновый цвет элемента body будет меняться в зависимости от размера окна просмотра. 
//      Цвет по умолчанию определен вне медиазапроса. Стили внутри медиазапросов 
//      будут заменять стили по умолчанию.  
//      body { background-color: grey; }
//      @media screen and (min-width: 320px) {
//          body { background-color: green; }
//      }
//      @media screen and (min-width: 550px) {
//          body { background-color: yellow; }
//      }
//      @media screen and (min-width: 768px) {
//          body { background-color: orange; }
//      }
//      @media screen and (min-width: 960px) {
//          body { background-color: red; }
//      }

// Выражение медиазапроса можно инвертировать, если добавить 'not' в начало 
//      медиазапроса. Эту возможность следует применять, когда это действительно
//      необходимо, чтобы писать краткие и простые медиазапросы.
//      <link rel="stylesheet" href="portrait-screen.css"
//          media="not screen and (orientation: portrait)" />

// Запросы можно комбинировать:
//      - один запрос который удовлетворяет двум условиям сразу:
//          @media ( ... ) and ( ... ) { ... }
//      - два запроса через запятую с одинаковыми стилями
//          @media ( ... ), ( ... ) { ... }

// Одно выражение может состоять из нескольких частей, соединенных операцией and.
//      Медиазапрос будет выполнятся, если выполняются все части выражения.
//      <link rel="stylesheet" href="800wide-portrait-screen.css"
//          media="screen and (orientation: portrait) and (minwidth: 800px)" />

// Условие медиазапроса может включать несколько выражений через запятую, что
//      аналогично операции or.
//      <link rel="stylesheet" href="800wide-screen-print.css"
//          media="screen and (minwidth: 800px), print" />

// Для медиазапросов можно использовать любую единицу измерения длины CSS. 
//      Чаще используются пикселы, но подойдут также единицы em и rem.

// В медиазапросах можно использовать сокращенный синтаксис. Если не нужно
//      указывать конкретный тип медиаустройств, то условие 'screen and' или 
//      'all and' можно опустить.
//      @media (min-width: 750px) { ... }

// --- 18.4 Типы носителей: screen, print.

// Медиазапросы могут быть нацелены на тип носителя: screen (экран) и print (принтер).

// РЕКОМЕНДАЦИЯ:
//      при печати следует: 
//      - скрывать несущественные части страницы, такие как навигационные меню, 
//          сделать это можно при помощи свойства 'display: none'
//      - цвета шрифтов поменять на черный
//      - удалить фоновые изображения и цвета подложек
//      - использовать универсальный селектор
//          @media print {
//              * {
//                  color: black !important;
//                  background: none !important;
//              }
//          }

// РЕКОМЕНДАЦИЯ:
//      при выборе контрольных точек следует протестироват несколько контрольных 
//      точек, чтобы найти подходящую, колонки макета не должны быть слишком узкими, 
//      не следует задумываться о разрешениях экранов конкретных устройств, контрольные 
//      точки должны выбиратся в соответствии с дизайном.

// --- 18.5 Медиасвойства.

// width - ширина окна просмотра;
// height - высота окна просмотра;
// device-width - ширина поверхности отображения;
// device-height - высота поверхности отображения;
// orientation - ориентация устройства: портретная или альбомная;
// aspect-ratio - соотношение сторон окна просмотра: 'aspect-ratio:16/9';
// device-aspect-ratio - соотношение сторон поверхности отображения устройства;
// color - количество битов на каждую составляющую цвета: 'min-color:16' выбирает
//       устройства, обладающие цветом с глубиной 16 бит;
// color-index - количество вхождений в таблице поиска цветов устройства;
// monochrome - количество битов на пиксель в монохромном буфере;
// resolution - разрешение экрана или принтера: 'min-resolution: 300dpi';
// scan - значения развертки телевизионных устройств: 
//      для устройства с параметрами 720p HDTV ('p' означает progressive) 
//          используется выражение 'scan: progressive'
//      для устройства 1080i HDTV ('i' означает interlaced) 
//          используется выражение 'scan: interlace'
// grid - показывает, на какой основе построено устройство: сеточной или растровой.

// Все медиасвойства, за исключением scan и grid, могут использовать префиксы 
//      min или max. Файл tiny.css может быть импортирован для экранов с шириной 
//      окна просмотра от 200px до 360px.
//      @import url("tiny.css") screen and (min-width:200px) and (max-width:360px);

// В спецификации 'Media Queries Level 4' не рекомендуется использовать: device-height,
//      device-width, device-aspect-ratio и другие.
//      https://drafts.csswg.org/mediaqueries-4/#mf-deprecated

// РЕКОМЕНДАЦИЯ:
//      для задания контрольных точек (условий медиазапроса) следует использовать 
//      единицы em, что обеспечивает одинаковый результат во всех браузерах.

// РЕКОМЕНДАЦИЯ:
//      лучший способ ориентации на экран высокой четкости, работает во всех браузерах:
//      @media (-webkit-min-device-pixel-ratio:2), @media(max-resolution: 192dpi) {}

// РЕКОМЕНДАЦИЯ:
//      организация кода при помощи добавления медиазапроса в элемент link, таблица 
//      стилей будет загружена, но применяться будет только если выполнятся условия 
//      медиазапроса:
//      <link rel="stylesheet" media="(min-width: 45em)" href="large-screen.css" />

// РЕКОМЕНДАЦИЯ:
//      общая структура стилей при использовании медиазапросов:
//      - мобильные стили, применяются ко всем контрольным точкам
//          .title {}
//      - средняя контрольная точка, переопределяет мобильные стили
//           @media (min-width: 35em) {
//               .title {}
//           }
//      - большая контрольная точка, переопределяет мобильные и средние стили
//           @media (min-width: 50em)
//               .title {}
//           }

// РЕКОМЕНДАЦИЯ:
//      для определния мобильных стилей можно использовать медиазапроса max-width, 
//      что удобно если приходится переопределять слишком много стилей в средней 
//      точке, иначе это может противоречить подходу 'Mobile First'.

// --- --- контрольные точки (Breakpoint)

// Контрольная точка определяет конкретную ширину и высоту области просмотра, 
//      при которой отзывчивый дизайн заметно меняется. Отзывчивый дизайн не зависит 
//      от размера экрана и подстраивается под любое окно просмотра, поэтому 
//      контрольные точки не должны определять список конкретных размеров устройств.

// РЕКОМЕНДАЦИЯ:
//      нет никаких конкретных контрольных точек, следует использовать те точки, 
//      которые нужны для дизайна, а не для конкретного устройства! 

// В следующем правиле: 
//      - директива @media сообщает браузеру о начале медиазапроса;
//      - screen указывает, что правила должны применяться ко всем типам экранов;
//      - условие 'min-width:800px' является контрольной точкой и означает, что
//          медиазапрос выполняться для экранов шириной не менее 800px;
//      @media screen and (min-width: 800px) { ... }

// Перед медиазапросами следует записать базовые правила для большинства основных 
//      устройств. Медиазапросы добавляются по мере необходимости для поддержки
//      новых устройств и разрешений области просмотра. Такой подход помогает 
//      мыслить в рамках принципа 'сначала маленькие экраны' и позволяет постепенно 
//      добавлять детали для больших экранов.

// --- 18.6 Написание медиазапросов.

// Сначала следует написать стили без медиазапросов. После чего добавляются 
//      медиазапросы с постепенно увеличивающейся областью просмотра и необходимыми
//      изменениями. Базовые стили остаются в исходном виде. Все различия 
//      инкапсулируются с помощью медиазапросов.

// Медиазапрос для области просмотра шириной 1200px и выше. 
//      @media (min-width: 1200px) {
//          .rwd-MastHead {
//              flex-direction: row;
//              justify-content: space-between;
//              max-width: 1000px;
//              margin: 0 auto;
//          }
//      }

// Медиазапрос для области просмотра шириной 1000px и выше. Ширина полей и 
//      отступов для элемента .rwd-nav будет равна нулю.
//      @media (min-width: 1000px) {
//          .rwd-nav {
//              margin: 0;
//              padding: 0;
//          }
//      }

// --- --- размещение медиазапросов

// Медиазапросы можно разместить ниже правил по умолчанию. Например, если нужно
//      изменить ширину двух элементов в разных местах таблицы стилей в зависимости 
//      от ширины окна просмотра.
//      .thing1 {
//          width: 50%;
//      }
//      @media (min-width: 30rem) {
//          .thing1 {
//              width: 75%;
//          }
//      }
//      .thing2 {
//          width: 65%;
//      }
//      @media (min-width: 30rem) {
//          .thing2 {
//              width: 75%;
//          }
//      }

// Медиазапросы можно сгруппировать в единый блок, но это негативно отразится 
//      на сопровождении кода. Чтобы не искать отдельные блоки кода, относящееся 
//      к конкретному селектору, следует располагать изменения правил для отдельного 
//      селектора непосредственно после их определения.
//      .thing {
//          width: 50%;
//      }
//      .thing2 {
//          width: 65%;
//      }
//      @media (min-width: 30rem) {
//          .thing {
//              width: 75%;
//          }
//          .thing2 {
//              width: 75%;
//          }
//      }

// Все ресурсы на сервере подвергаются gzip-сжатию. Поэтому размер файла вырастет 
//      незначительно, если медиазапросы будут записываться после стандартных стилей.
//      Идентичные определения медиазапросов могут быть собраны в один запрос
//      при помощи инструментов сборки: Grunt или Gulp.

// --- 18.7 Медиафункции.

// Медиафункции взаимодействия связаны с указывающими устройствами и возможностью 
//      наведения.

// --- --- медиафункция pointer

// Спецификация:
//      https://www.w3.org/TR/mediaqueries-4/#pointer

// Существует три возможных состояния указателя pointer: none (отсутствует), 
//      coarse (грубый) и fine (точный).

// Устройством типа 'coarse' может быть палец на сенсорном экране или курсор 
//      игровой консоли.
//      @media (pointer: coarse) {
//          стили на случай присутствия указателя, имеющего состояние coarse
//      }

// Устройством типа fine может быть мышь, стилус или другой указательный 
//      механизм высокой точности.
//      @media (pointer: fine) {
//          стили на случай присутствия указателя, имеющего состояние fine
//      }

// Значение pointer определяется браузерами в зависимости от основного устройства
//      указателя. Устройство точного указателя не обязательно должно быть 
//      основным. Например, для планшета основным указателем является не точный 
//      палец, но к нему прикреплен точный стилус. Разумнее предполагать, что 
//      пользователи работают с устройством сенсорного ввода, тогда с интерфейсом
//      не будет проблем, даже если они используют мышь.

// --- --- медиафункция hover

// Медиафункция hover тестирует возможность проведения указателя над элементами 
//      экрана. Использует характесристики основного устройства ввода.

// Если провести указатель над элементами невозможно.
//      @media (hover: none) { ... }

// Если пользователь может провести указатель над элементами.
//      @media (hover) { ... }

// Медиафункции any-pointer и any-hover аналогичны pointer и hover, но проверяют 
//      возможности для всех устройств ввода независимо от основного устройства.

// Если несколько устройств могут быть указателем.
//      @media (any-hover: hover) { ... }

// Если примененный указатель является грубым.
//      @media (any-pointer: coarse) { ... }

// --- --- медиафункция prefers-color-scheme

// Спецификация:
//      https://drafts.csswg.org/mediaqueries-5/#prefers-color-scheme

// Медиафункция prefers-color-scheme позволяет выбрать ночной режим и предоставляет 
//      три вариант: light, dark, nopreference. 

// Цвета по умолчанию записываются сверху таблицы, а медиазапрос для альтернативного
//      цвета ниже.
//      body {
//          background-color: #e4e4e4;
//          color: #545454;
//      }
//      @media (prefers-color-scheme: dark) {
//          body {
//              background-color: #333;
//              color: #ddd;
//          }
//      }

// --- 18.8 Правило @supports.

// Запрос @supports - это запрос возможностей (feature queries), которые
//      могут применяться в правилах CSS.

// Правила не будут действовать, поскольку ни один браузер не поддерживает 
//      выдуманное свойство flashing-sausages.
//      @supports (flashing-sausages: lincolnshire) {
//          body {
//              sausage-sound: sizzling;
//              sausage-color: slighty-burnt;
//              background-color: brown;
//          }
//      }

// Flexbox будет использоваться, если браузер поддерживает эту технологию.
//      @supports (display: grid) {
//          .Item {
//              display: inline-grid;
//          }
//      }
//      @supports not (display: grid) {
//          .Item {
//              display: inline-flex;
//          }
//      }

// В браузере может отсутствовать поддержка @supports, поэтому следует сначала
//      добавить базовые правила без @supports, а потом проверку @supports.
//      Если браузер поддерживает @supports, то первое правило будет отменено, 
//      иначе будут игнорироваться правила в @supports. 
//      .Item {
//          display: inline-flex;
//      }
//      @supports (display: grid) {
//          .Item {
//              display: inline-grid;
//          }
//      }

// Условия в запросах @supports можно комбинировать. 
//      @supports ((display: flex) and (pointer: coarse)) {
//          .Item {
//              display: inline-flex;
//          }
//      }

// Аналогично медизапросам, рекомендуется сначала определить стили 
//      по умолчанию, а затем вносить усложнения внутри запроса @supports.
//      @supports ((display: flex) and (pointer: coarse)) or (transform: translate3d(0, 0, 0)) {
//          .Item {
//              display: inline-flex;
//          }
//      }