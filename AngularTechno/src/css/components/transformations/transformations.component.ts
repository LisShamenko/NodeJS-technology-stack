import { Component } from "@angular/core";

@Component({
    selector: "transformations-component",
    templateUrl: "./transformations.template.html",
    styleUrls: ["./transformations.style.css"],
})
export class TransformationsComponent { }

// --------------- Вращение, масштабирование, смещение и наклон

// - функции трансформирования: вращение, смещение, масштабирование, наклон

// - при трансформации элемента, его действительное положение не меняется и не влияет на другие элементы,
//      но может перекрывать другие элементы или выйти за пределы экрана, проблему можно решить задав поля
//      для элемента

// - трансформация не применяется к некоторым строчным элементам, в этом случае следует заменить свойство 
//      'display:inline' на любое другое ('display:inline-block'), применить Flex или CSS-сетку, для этого
//      следует установить свойства 'display:flex' или 'display:grid' соответственно для родительского элемента

// --------------- Изменение точки трансформации

// - трансформации выполняются относительно точки трансформации, которой по умолчанию является центр элемента,
//      для задания точки трансформации используется свойство transform-origin, можно указать несколько 
//      свойств через запятую

// - точка трансформации задается в процентах или ключевыми словами [left,center,right] / [top,center,bottom]
//      по горизонтали и вертикали, также можно использовать измерение длины [px, em, и другие единицы измерения]:
//          transform-origin: right center;     - справа по центру
//          transform-origin: 100% 50%;         - тоже самое в процентах

// --------------- Производительность анимации

// анимации более требовательны к ресурсам, чем трансформации, поэтому следует отдать предпочтение 
//      трансформациям для явного задания позиции и размера

// --------------- Рендеринг страницы

// рендеринг - процесс визуализации элементов браузером, преобразование стилей в пиксели, рендеринг можно
//      разбить на три стадии: разметка, окрашивание, компоновка 

// 1. разметка
//      на этой стадии браузер определяет размер и положение каждого элемента, 
//      разметка будет пересчитываться заново при изменении размеров или расположения 
//      элементов, а так же если элемент создается или удаляется с помощью DOM JavaScript

// 2. окрашивание
//      это стадия заполнения пикселов: отрисовка текста, изображений, цвета границ и теней
//      изображения раскрашиваются по слоям, элементы будут перерисовыватсья при изменении, например, 
//      цвета фона, но при этом не происходит пересчета разметки, что требует гораздо меньше вычислений
//      каждый слой отрисовывается независимо от других слоев на странице, браузер отправляет слои в GPU
//      на рендеринг, главный слой обрабатывается в центральном процессоре (CPU), в идеале каждый элемент
//      должен иметь свой слой, чем больше слоев тем больше потребляемой памяти и меньше время рендеринга

// 3. компоновка
//      - на этой стадии все отрисованные слои собираются вместе и создается единое изображение для 
//          отображения, слои собираются в определенном порядке, так что одни отображаются поверх других 
//      - войства opacity и transform значительно сокращает время рендеринга, элементы к которым применяются 
//          эти свойства помещаются браузером на отдельный цветовой слой и может задействоваться аппаратное 
//          ускорение, так как элемент находится на отдельном слое, то основной слой остается неизменным,
//          что не требует повторных вычислений
//      - при создании переходов и анимации следует использовать преимущественно свойства opacity и 
//          transform, тогда изменения коснутся только формирования слоев, а не разметки в целом,
//          разметку затрагивать следует только если нет другого выхода и всегда следует думать о 
//          возможных проблемах с производительностью (https://csstriggers.com/)

// - свойство will-change позволяет контролировать слои, оно заранее сообщает браузеру какие изменения 
//      элемента стоит ожидать и элемент помещается на отдельный слой, но это свойство следует использовать
//      только при реальных проблемах с производительностью
//      https://dev.opera.com/articles/css-will-change-property/

// --------------- Трехмерные (3D) трансформации

// translateZ выполняет смещение по оси Z, что отдаляет или приближает элемент относителньо пользователя
// rotateX вращает элемент вокруг горизонтальной оси X (наклоняя элемент вперед или назад)
// rotateY вращает элемент вокруг вертикальной оси Y (поворачивая элемент вправо или влево)
// rotateZ (эквивалентна rotate) выполняет вращение вокруг оси Z

// --------------- Свойство перевернутого изображения

// при указании значений свыше 90° для rotateX или rotateY изображение будет развернуто, при 180° 
//      зеркально отражено, отображемое изображение будет являться обратной стороной исходного,
//      свойство 'backfасе-visibility:hidden' позволяет скрыть обратную сторону элемента
//      https://3dtransforms.desandro.com/card-flip

// --------------- Контроль перспективы

// - трансформированные элементы вместе образуют 3D-сцену, перспективу можно рассматривать как 
//      расстояние между камерой и сценой

// - перспектива задается двумя способами: трансформация perspective() или свойство perspective

// --------------- Профессиональные приемы 3D-трансформации

// - свойство perspective-origin смещает камеру вправо или влево, вверх или вниз
// - по умолчанию перспектива отображается так, как если бы наблюдатель находился по центру элемента

// --------------- Свойство transform-style (preserve-3D)

// https://html5book.ru/3d-transform/