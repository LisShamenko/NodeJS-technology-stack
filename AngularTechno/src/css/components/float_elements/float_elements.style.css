.real-header {
    color: red;
    padding: 20px;
    font-size: 20px;
}

[id^="example-"] {
    border-width: 1px;
    border-style: solid;
    padding: 5px;
    margin: 5px;
}

/* --------------- Основные стили. */

.body {
    /* селектор ':root' заменяется на .body  */
    box-sizing: border-box;
}

.body *, .body ::before, .body ::after {
    box-sizing: inherit;
}

.body {
    background-color: #eee;
    font-family: Helvetica, Arial, sans-serif;
}

/* глобальные поля с помощью селектора лоботомированной совы */

/*
.body *+* {
    margin-top: 1.5em;
}
*/

/* Цвета и отступы шапки */

#example-1 header, #example-2 header {
    padding: 1em 1.5em;
    color: #fff;
    background-color: #0072b0;
    border-radius: .5em;
    margin-bottom: 1.5em;
}

/* Цвета и отступы основного контейнера */

#example-1 .main, #example-2 .main {
    padding: 1.5em 1.5em 0 1.5em;
    background-color: #fff;
    border-radius: .5em;
}

#example-1.ex-container, #example-2.ex-container, #example-3.ex-container {
    /* 
     * ограничение максимальной ширины в 1080 пикселов
     * контейнер заполнит меньшие области просмотра, в больших областях просмотра расширится до 1080px,
     * это исключит горизонтальное прокручивание на устройствах с небольшой областью просмотра
     */
    max-width: 1080px;
    /* 
     * автоматизация увеличения левого и правого полей для заполнения доступного пространства и 
     * центрирования элемента относительно внешнего контейнера. 
     */
    margin: 0 auto;
}

/* --------------- выравнивание плавающих элементов по левому краю */

#example-1 .media, #example-2 .media {
    /* выравнивание плавающих элементов по левому краю */
    float: left;
    /* по горизонтали должны вмещаться два блока */
    width: 50%;
    padding: 1.5em;
    background-color: #eee;
    border-radius: 0.5em;
}

/* --------------- сброс обтекания плавающих элементов */

#example-1 .clear-div {
    /* добавляется пустой контейнер div со свойством clear в конец основного контейнера */
    clear: both;
}

/* --------------- метод clearfix */

/*
 * clearfix - общий подход к решению проблемы умещения плавающих элементов,
 * имя класса clearfix можно заменить на cf (containing floats),
 * класс clearfix применяется к элементу, содержащему пла­вающие элементы
 */

#example-2 .clearfix::after {
    /* 
     * нацеливается на псевдоэлемент, находящийся в конце контейнера 
     * свойства приводят к появлению псевдоэлемента элемента в документе 
     */
    display: block;
    /* 
     * исправляет незаметную ошибку в старых версиях браузера Opera, 
     * пустая строка "" тоже приемлема
     */
    content: " ";
    /* сбрасывает обтекание всех плавающих элементов */
    clear: both;
}

/* --------------- модифицированный метод clearfix */

#example-2 .clearfix::before, #example-2 .clearfix::after {
    /* 
     * приводит к появлению псевдоэлементов ::before и ::after и предотвращает схлопывание полей:
     * создание табличного элемента (псевдоэлемента) неявно создает строку таблицы с ячейкой внутри 
     * этого элемента, при этом поля не схлопываются через табличные элементы (псевдоэлемент),
     * 'display: table-cell' не применимо, так как свойство clear работает только с блочными элементами
     */
    display: table;
    content: " ";
}

#example-2 .clearfix::after {
    /* Только псевдоэлемент ::after нуждается в сбросе обтекания плавающих элементов */
    clear: both;
}

/* --------------- Захват плавающего элемента. */

#example-2 .media:nth-child(odd) {
    /* первый элемент (нечетный) в каждой строке должен сбрасывать обтекание плавающего элемента */
    clear: left;
    /* нацелить селектор на каждый третий элемент: '.media: nth-child(Зn+1)' */
}

#example-2 .media {
    /* добавляет правое и нижнее поля к каждому элементу */
    margin: 0 1.5em 1.5em 0;
    /* вычитает значение поля из ширины во избежание нежелательного обтекания строки */
    width: calc(50% - 1.5em);
    /* 
     * для контейнера устанавливается свойство 'padding: 1.5em 1.5em 0 1.5em'
     *      то есть контейнер не имеет поля снизу
     * для карточки устанавливается свойство 'margin: 0 1.5em 1.5em 0'
     *      то есть образуется поле между карточками и 
     *      компенсируется отсутствие поля контейнера снизу
     */
}

/* --------------- Блочный контекст форматирования. */

.media-image-first {
    /* выравнивание плавающего изображения по левому краю */
    float: left;
}

.media-body-first {
    /* удаление верхнего поля с помощью селектора лоботомированной совы */
    margin-top: 0;
}

.media-body-first h4 {
    /* переопределение верхнего поля, создаваемого с помощью браузерных стилей */
    margin-top: 0;
}

/* --------------- Блочный контекст форматирования: 'overflow: auto'. */

/* использование свойства 'overflow: auto' самый простой подход */

.media-image {
    float: left;
    /* промежуток между изображением и телом */
    margin-right: 1.5em;
}

.media-body {
    margin-top: 0;
    /* установка нового блока контекста форматирования */
    overflow: auto;
}

.media-body h4 {
    margin-top: 0;
}

/* --------------- Блочный контекст форматирования: 'float: left'. */

/* 
 * - 'float: left;'             плавающий или строчно-блочный элемент увеличится до 
 *                              100% ширины, что потребует ограничить ширину элемента 
 * - 'display: table-cell'      ячейка таблицы увеличится до размеров своего контента,
 *                              что потребует увеличить ширину для заполнения контейнера
 */

.media-body-second {
    margin-top: 0;
    /* установка нового блока контекста форматирования */
    float: left;
    width: 300px;
}

.media-body-second h4 {
    margin-top: 0;
}

/* --------------- CSS-сетка. */

#example-3 .main {
    padding: 1.5em;
    background-color: #fff;
    border-radius: .5em;
}

#example-3 .media {
    padding: 1.5em;
    background-color: #eee;
    border-radius: 0.5em;
    margin: 0;
    border: solid 1px;
}

#example-3 .media-image {
    float: left;
    margin-right: 1.5em;
}

#example-3 .media-body {
    overflow: auto;
    margin-top: 0;
}

#example-3 .media-body h4 {
    margin-top: 0;
}

/* этот код избавляет от добавления класса clearfix в каждый элемент '<div class="row">'. */

.row::after {
    /* репликация метода clearfix, чтобы строка содержала плавающие колонки */
    content: " ";
    display: block;
    clear: both;
}

/* растянуть строку, используя отрицательные значения полей */

.row {
    margin-left: -0.75em;
    margin-right: -0.75em;
}

/* плавающие колонки выравниваются по левому краю и задается ширина */

[class*="column-"] {
    /* 
     * нацеливается на все элементы с атрибутом класса "column-" 
     * селектор атрибутов [] нацеливается на элементы по их атрибуту class
     * компаратор *= устанавливает любые значения, в которых встречается указанная подстрока
     */
    float: left;
    /* добавляет отступ размером 0.75em справа каждому элементу колонки */
    padding: 0.75em 0.75em;
    /* удаляет верхние поля колонок */
    margin-top: 0;
}

/* 
 * чтобы определить ширину: желаемое количество колонок делится на общее количество колонок 
 * 12 делится на [2, 3, 4, 6] что обеспечивает большую пластичность
 */

.column-1 {
    width: 8.3333%;
}

.column-2 {
    width: 16.6667%;
}

.column-3 {
    width: 25%;
}

.column-4 {
    width: 33.3333%;
}

.column-5 {
    width: 41.6667%;
}

.column-6 {
    width: 50%;
}

.column-7 {
    width: 58.3333%;
}

.column-8 {
    width: 66.6667%;
}

.column-9 {
    width: 75%;
}

.column-10 {
    width: 83.3333%;
}

.column-11 {
    width: 91.6667%
}

.column-12 {
    width: 100%
}