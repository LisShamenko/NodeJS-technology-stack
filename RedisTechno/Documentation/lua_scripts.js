"use strict";

const redis = require("redis");


//      https://redis.io/commands/eval
//      https://redis.io/commands/script-kill
//      https://redis.io/commands/function-kill
//      https://redis.io/commands/config-set

// --------------- 7. Lua Scripts.

// Redis - это предметно-ориентированный язык для абстрактных типов данных (domain-specific 
//      language for abstract data types). Язык Redis построен на командах управления 
//      данными. Programmability - это возможность выполнения сервером пользовательской
//      логики через скрипты. Это позволяет реализовывать надежные API, которые могут
//      инкапсулировать бизнес-логику и поддерживать модель данных с несколькими ключами и 
//      различными структурами данных.

// Сценарии в Redis выполняются с помощью интерпретатора Lua 5.1.

// --- 7.1 Запуск скриптов

// Redis предоставляет два способа запуска скриптов: 
//      - Redis Eval Scripts;
//      - Redis Functions;

// Команда EVAL позволяет запускать сценарии на стороне сервера, но при этом логика 
//      сценария становится частью приложения, то есть каждый экземпляр приложения 
//      должен иметь исходный код сценария. По мере роста приложения этот подход 
//      может стать слишком сложным для разработки и поддержки.

// Функции Lua - это сценарии базы данных, которые отделяют код Lua от логики приложения,
//      обеспечивают независимую разработку, тестирование и развертывание сценариев. 
//      Сначала функции следует загрузить на сервер, что является административной 
//      задачей, после чего они станут доступны всем подключенным клиентам. 

// Redis гарантирует атомарное выполнение скриптов аналогично транзакциям в других 
//      базах данных. При выполнении скриптов сервер блокируется для всех подключенных
//      клиентов. Из этого следует, что выполнение медленных сценариев является плохой 
//      идеей, поскольку другие клиенты не могут выполнять команды во время работы 
//      скриптов. Блокировка означает, что все эффекты сценария либо еще не произошли, 
//      либо уже произошли. 

// Сценарии предлагают несколько полезных свойств:
// - локальность, то есть логика выполняется там же, где находятся данные, что снижает 
//      общую задержку и экономит сетевые ресурсы;
// - блокирующая семантика обеспечивает атомарное выполнение скрипта;
// - набор простых возможностей, которые отсутствуют в Redis.

// --- 7.2 Изолированный контекст (Sandbox Context).

// Скрипты Lua выполняются в изолированном контексте, что позволяет Redis предотвратить 
//      неправильное использование и уменьшить угрозы со стороны серверной среды.
//      Сценарии никогда не должны пытаться получить доступ к базовым хост-системам 
//      сервера Redis, таким как файловая система, сеть, или пытаться выполнить любой 
//      другой системный вызов, кроме тех, которые поддерживаются API. Скрипты должны 
//      работать исключительно с данными, которые хранятся в Redis или предоставляются
//      в качестве аргументов.

// --- 7.3 Максимальное время выполнения.

// Максимальное время выполнения по умолчанию установлено на пять секунд, что является
//      избыточным значением, поскольку сценарии обычно выполняются менее чем за 
//      миллисекунду. Это ограничение существует для обработки случайных бесконечных 
//      циклов.

// Максимальное время выполнения можно изменить с точностью до миллисекунды с помощью 
//      команды CONFIG SET или через файл конфигурации redis.conf с помощью параметра 
//      busy-reply-threshold.

// При достижении скриптом максимального времени выполнения, Redis не завершает его 
//      автоматически, что нарушело бы контракт между Redis и обработчиком сценариев, 
//      который гарантирует атомарность сценариев.

// Если скрипт выполняется дольше максимального времени выполнения, происходит следующее:
//      - Redis регистрирует, что скрипт выполняется слишком долго;
//      - Redis начинает принимать команды от других клиентов, но при этом отвечает 
//          с ошибкой BUSY всем клиентам, в этом состоянии разрешены только команды 
//          [SCRIPT KILL, FUNCTION KILL, SHUTDOWN NOSAVE];
//      - если сценарий выполнил только команды чтения, то его можно завершить 
//          с помощью команд [SCRIPT KILL, FUNCTION KILL], эти команды не нарушают 
//          семантику скрипта, так как скрипт не выполнил запись данных в результирующий
//          набор;
//      - если сценарий выполнил хотя бы одну операцию записи, то единственной 
//          разрешенной командой будет SHUTDOWN NOSAVE, которая останавливает 
//          сервер без сохранения результирующего набора данных на диск, то есть
//          сервер прерывает свою работу.

// --- 7.4 Eval.

const lua_eval = require('./lua_eval');

// --- 7.5 Отладчик скриптов.

const lua_debugger = require('./lua_debugger');

// --- 7.6 Functions.

const lua_functions = require('./lua_functions');

async function redis_define_script() {

    // 
    const client = redis.createClient({
        scripts: {
            ADD: redis.defineScript({
                NUMBER_OF_KEYS: 1,
                SCRIPT: `
                    local val = redis.pcall("GET", KEYS[1]);
                    local bar = redis.pcall("GET", "bar");
                    return val + ARGV[1] + bar;
                `,
                transformArguments(key, toAdd) {
                    return [key, toAdd.toString()];
                },
                transformReply(reply) {
                    return reply;
                }
            })
        }
    });

    // 
    client.on('error', (err) => {
        console.log(`--- redis client error: ${err}`);
    });

    // 
    await client.connect();
    console.log(`--- redis: connection`);

    // 
    console.log(`--- key: setget
        --- SET foo = ${await client.SET('foo', '1')}
        --- SET bar = ${await client.SET('bar', '2')}
        --- ADD foo = ${await client.ADD('foo', 3)} 
        --- GET foo = ${await client.GET('foo')}
        --- GET bar = ${await client.GET('bar')}
    `);

    //
    client.quit();
}

// --- 7.7 API.

const lua_api = require('./lua_api');

// --- Запуск.

(async () => {
    await lua_eval();
    await lua_debugger();
    await lua_functions();
    await redis_define_script();
    await lua_api();
})();