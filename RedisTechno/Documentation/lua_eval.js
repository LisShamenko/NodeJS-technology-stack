"use strict";

const redis = require("redis");



//      https://redis.io/commands/script
//      https://redis.io/commands/script-flush
//      https://redis.io/commands/script-exists
//      https://redis.io/commands/script-kill
//      https://redis.io/commands/script-debug
//      https://redis.io/commands/evalsha
//      https://redis.io/commands/multi
//      https://redis.io/commands/exec
//      https://redis.io/commands/info

//      https://redis.io/topics/cluster-tutorial
//      https://redis.io/topics/replication

// --------------- 7.4 Eval.

// Команда Eval позволяет запускать часть логики приложения внутри Redis, например,
//      чтобы атомарно обновить несколько ключей разных типов данных. Скрипты Eval
//      выполняются на сервере, но считаются частью клиентского приложения. 
//      Все сценарии могут быть перезагружены приложением в любое время, если они 
//      отсутствуют, например, после перезапуска сервера или переключения на реплику.

// Команда EVAL вызывает выполнение скрипта Lua на стороне сервера:
//
//      EVAL script numkeys [key [key ...]] [arg [arg ...]]
//
//          script - исходный код скрипта на Lua;
//          numkeys - количество входных ключей;
//          [key [key ...]] - ключи, которые будут доступны для скрипта, как 
//              глобальная переменная времени выполнения KEYS;
//          [arg [arg ...]] - дополнительные аргументы, которые не явялются 
//              ключами;

// Сценарий передаваемый в команду EVAL не должен содержать определений функций Lua.

//      > EVAL "return 'Hello, scripting!'" 0
//          "Hello, scripting!"
//      > EVAL "return ARGV[1]" 0 hello
//          "hello"

// --- 7.4.1 Параметризация скрипта.

// Выполнение похожих скриптов является антишаблоном из-за соображений кэширования 
//      скриптов. Следует параметризовать один сценарий и передавать любые аргументы, 
//      необходимые для выполнения. 

//      > EVAL "return 'Hello'" 0
//          "Hello"
//      > EVAL "return 'Scripting!'" 0
//          "Scripting!"

//      > EVAL "return ARGV[1]" 0 Hello
//          "Hello"
//      > EVAL "return ARGV[1]" 0 Parameterization!
//          "Parameterization!"

// Команда EVAL принимает два типа входных аргументов: имена ключей и параметры,
//      передаваемые в сценарий.

// Сценарий может обращаться только к тем ключам, которые явно указаны в качестве 
//      входных аргументов. Сценарии никогда не должны обращаться к ключам, которые
//      сгененрированны программно или полученны, как содержимое базы данных.

// Контекст выполнения делает аргументы доступными для скрипта через глобальные 
//      переменные времени выполнения KEYS и ARGV. Таблица KEYS заполняется 
//      аргументами ключей, передаваемые сценарию перед его выполнением, таблица 
//      ARGV служит той же цели, но для обычных аргументов.

// Распределение входных аргументов между глобальными переменными времени выполнения 
//      скриптов KEYS и ARGV:

//      > EVAL "return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }" 2 key1 key2 arg1 arg2 arg3
//          1) "key1"
//          2) "key2"           массивы Lua возвращаются как массивы RESP2 
//          3) "arg1"
//          4) "arg2"
//          5) "arg3"

async function redis_params() {

    // 
    const client = redis.createClient({ url: process.env.REDIS_URL });
    client.on('error', (err) => {
        console.log(`--- redis client error: ${err}`);
    });

    // 
    await client.connect();
    console.log(`--- redis: connection`);

    //      export interface EvalOptions {
    //          keys?: Array<string>;
    //          arguments?: Array<string>;
    //      }

    // 
    console.log(`--- key: EVAL
        --- EVAL foo = ${await client.EVAL('return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] };', { keys: ['key1', 'key2'], arguments: ['arg1', 'arg2', 'arg3'] })}
    `);

    //
    client.quit();
}

// --- 7.4.2 Методы call/pcall.

// Команды Redis можно вызывать из скрипта Lua с помощью методов redis.call или 
//      redis.pcall. Оба метода выполняют команду Redis вместе с предоставленными 
//      аргументами. Разница между этими методами заключается в способе обработки 
//      ошибок времени выполнения. Ошибки, возникающие при вызове redis.call, 
//      возвращаются непосредственно клиенту. Ошибки, возникающие при вызове 
//      redis.pcall, возвращаются в контекст выполнения скрипта.

// Следующий сценарий принимает один ключ и один входной аргумент. Сценарий вызывает
//      команду SET, чтобы установить входной ключ.

//      > EVAL "return redis.call('SET', KEYS[1], ARGV[1])" 1 foo bar
//          OK

async function redis_call_pcall() {

    // 
    const client = redis.createClient({ url: process.env.REDIS_URL });
    client.on('error', (err) => {
        console.log(`--- redis client error: ${err}`);
    });

    // 
    await client.connect();
    console.log(`--- redis: connection`);

    // 
    console.log(`--- key: call/pcall
        --- SET     = ${await client.SET('foo', 'X')}
        --- call    = ${await client.EVAL(`return redis.call('SET', KEYS[1], ARGV[1]);`, { keys: ['foo'], arguments: ['bar'] })}
        --- pcall   = ${await client.EVAL(`return redis.pcall('SET', KEYS[1], ARGV[1]);`, { keys: ['foo'], arguments: ['bar'] })}
        --- GET     = ${await client.GET('foo')}
    `);

    //
    client.quit();
}

// --- 7.4.3 Кэш скриптов.

// Сценарии выполняемые с помощью EVAL хранятся в выделенном кеше на сервере. 
//      Содержимое кеша идентифицируется при помощи хеш-сумм SHA1. Проверить 
//      это можно, если вызвать команду INFO. Метрики usedmemoryscriptseval_ и
//      numberofcachedscripts_ будут расти при выполнении команд EVAL.

// Динамически генерируемые скрипты - это антишаблон. Создание сценариев во время 
//      выполнения может исчерпать ресурсы памяти хоста для их кэширования. Вместо 
//      этого сценарии должны быть как можно более общими и обеспечивать индивидуальное 
//      выполнение с помощью своих аргументов.

// Сценарий загружается в кеш сервера вызовом команды SCRIPT LOAD с исходным кодом. 
//      Сервер не выполняет скрипт, а просто компилирует и загружает его в кеш сервера. 
//      Кешированный скрипт можно выполнить при помощи команды EVALSHA.

//      > SCRIPT LOAD "return 'Immabe a cached script'"
//          "c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f"
//      > EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0
//          "Immabe a cached script"

async function redis_script_load() {

    // 
    const client = redis.createClient({ url: process.env.REDIS_URL });
    client.on('error', (err) => {
        console.log(`--- redis client error: ${err}`);
    });

    // 
    await client.connect();
    console.log(`--- redis: connection`);

    // 
    let sha1 = await client.SCRIPT_LOAD("return 'Immabe a cached script'");
    console.log(`--- key: EVAL
        --- EVAL foo = ${sha1}
        --- EVAL foo = ${await client.EVALSHA(sha1)}
    `);

    // 
    try {
        await client.EVALSHA('ffffffffffffffffffffffffffffffffffffffff');
    }
    catch (err) {
        console.log(`--- err = ${err}`);
    }

    //
    client.quit();
}

// --- --- Cache volatility.

// Кеш скриптов Redis является непостоянным 'always volatile', не считается частью базы 
//      данных и не сохраняется 'not persisted'. Кеш может быть очищен при перезапуске 
//      сервера, во время отработки отказа, когда реплика принимает на себя главную роль 
//      или явным образом с помощью SCRIPT FLUSH. То есть содержимое кеша может быть 
//      утеряно в любое время.

// Для выполнения сценариев следует всегда вызывать EVALSHA. Для этого сначала следует
//      вызвать команду SCRIPT LOAD, чтобы получить хеш-сумму, с помощью которой можно
//      вызвать скрипт. Сервер будет возвращать ошибку, если хеш-сумма скрипта 
//      отсутствует в кеше. 

//      > EVALSHA ffffffffffffffffffffffffffffffffffffffff 0
//          (error) NOSCRIPT No matching script

// --- --- EVALSHA в контексте конвейера.

// Pipelined request - конвейерный запрос.
// Context pipelining - контекст конвейера.

// Команды в конвейерном запросе выполняются в порядке их отправки, но команды других 
//      клиентов могут чередоваться для выполнения между ними. Из-за этого ошибка NOSCRIPT 
//      может возвращаться из конвейерного запроса, но не может быть обработана. В этом 
//      случае следует использовать обычный EVAL, параметризованный в контексе конвейера.

// --- --- Семантика кэша скриптов.

// При нормальной работе приложения сценарии остаются в кеше неопределенное время, до тех 
//      пор, пока кеш не будет сброшен любым способом. Содержимое кэша хорошо написанного 
//      приложения не будет расти и даже большие приложения не должны испытывать проблем 
//      с использованием памяти кеша.

// Команда SCRIPT FLUSH позволяет полностью очистить кеш скриптов. Это необходимо только 
//      в том случае, если будет создан еще один экземпляр сервера Redis для другого 
//      клиента или приложения в облаке.

// Перезапуск сервера Redis очищает кеш скриптов. С точки зрения клиента есть только 
//      два способа убедиться, что сервер не был перезапущен:
//      - соединение с сервером является постоянным и до сих пор никогда не закрывалось;
//      - проверка поля runid через команду INFO, которая содержит идентификатор 
//          серверного процесса.

// С практической точки зрения клиенту гораздо проще предположить, что в контексте 
//      данного соединения кэшированные сценарии гарантированно будут присутствовать, 
//      если только администратор явно не вызовет команду SCRIPT FLUSH. Тот факт, 
//      что пользователь может рассчитывать на то, что Redis сохранит кэшированные 
//      сценарии, семантически полезен в контексте конвейерной обработки.

// --- 7.4.4 Команда SCRIPT.

// Команда SCRIPT FLUSH позволяет очистить кеш скриптов. Команда полезна для тестирования
//      сценариев, с также в средах, где один и тот же экземпляр Redis переназначается 
//      для разных целей. 

// Команда SCRIPT EXISTS определяет был ли сценарий загружен в кеш или нет.

// Команда SCRIPT LOAD регистрирует указанный скрипт в кэше скриптов Redis. Команда 
//      полезная, когда необходимо убедиться, что EVALSHA не даст сбой без выполнения 
//      скрипта, например, при использовании конвейера или транзакций.

// Команда SCRIPT KILL позволяет прервать долго выполняющийся сценарий без отключения 
//      сервера. Сценарий является 'long-running script' или 'slow script', если 
//      продолжительность его выполнения превышает максимальное время выполнения. 
//      Эту команду можно использовать только со сценариями, которые не выполняли
//      операции записи в результирующий набор, то есть не нарушали атомарность.

// Команда SCRIPT DEBUG контролирует встроенный отладчик скриптов Lua.

// --- 7.4.5 Репликация.

// В автономном развертывании один экземпляр Redis, называемый master, управляет 
//      всей базой данных. В кластерном развертывании есть как минимум три мастера, 
//      управляющие сегментированной базой данных. Redis использует репликацию 
//      для поддержки одной или нескольких реплик или точных копий для любого 
//      заданного мастера.

// Поскольку сценарии могут изменять данные, Redis гарантирует, что все операции 
//      записи, выполняемые сценарием, также отправляются в реплики для обеспечения 
//      согласованности. 

// Существует два концептуальных подхода к репликации сценариев:

// 1. Verbatim replication: мастер отправляет исходный код сценария репликам, затем 
//      реплики выполняют сценарий и операции записи. Этот режим экономит полосу 
//      пропускания репликации, когда сценарии генерируют множество команд, например, 
//      в циклах for. Но при этом реплики выполняют ту же работу, что и мастер, а это 
//      расточительно. Также этот режим требует, чтобы все сценарии записи были 
//      детерминированными. Начиная с Redis 7.0 не поддерживается. Для включения 
//      режима используются: lua-replicate-commands и API.redis.replicate_commands.

// 2. Effects replication: реплицируются только команды скрипта, изменяющие данные,
//      затем реплики запускают команды без выполнения каких-либо сценариев. Этот 
//      режим является детерминированным по определению, но при этом требует большего 
//      сетевого трафика. Начиная с Redis 5.0 является режимом по умолчанию.

// --- --- Effects replication.

// В этом режиме репликации при выполнении сценария, Redis собирает все команды, 
//      выполняющие запись данных. После завершения сценария команды упаковываются 
//      в MULTI/EXEC транзакции, а потом отправляются на реплики и AOF.

// Режим 'effects replication' полезен в ряде случаев:
// - если сценарий вычисляется медленно и результаты можно суммировать с помощью 
//      нескольких команд записи, то нет смысла полностью выполнять сценарий 
//      на репликах или при перезагрузке AOF;
// - если требуется выполнять недетерминированные функции, например, можно свободно 
//      использовать команды TIME или SRANDMEMBER;
// - Lua PRNG в этом режиме заполняется случайным образом при каждом вызове;

// До Redis 7.0 необходимо выполнить функцию Lua, чтобы сценарий выполнил запись:
//      redis.replicate_commands. Функция возвращает true, если включен режим 
//      'effects replication'; если функция была вызвана после того, как скрипт 
//      вызвал команду записи, то функция вернет false и будет использоваться 
//      репликация всего скрипта. 

// После Redis 7.0 функция redis.replicate_commands всегда возвращает true.

// --- --- Verbatim replication.

// В режиме 'verbatim replication' мастер отправляет сценарий своим репликам, затем
//      сценарий повторно запускается на удаленном хосте. Изменения, создаваемые
//      этим сценарием в базе данных должны быть детерминированными, то есть 
//      не должны зависеть от случайных факторов.

// Отправка сценария целиком может оказаться намного быстрее, чем отправка 
//      нескольких команд, генерируемых сценарием. Если требуется выполнить 
//      несколько сценариев, то мастеру потребуется преобразовать каждый сценарий 
//      в последовательность команд для реплики или AOF, что приведет к сильной 
//      загрузке канала репликации или файла AOF, а также к слишком большой 
//      загрузке ЦП.

// Недостаток этого подхода заключается в том, что сценарии должны обладать следующим 
//      свойством: сценарий всегда должен выполнять одни и те же команды записи Redis
//      с одинаковыми аргументами для одного и того же набора входных данных. Операции, 
//      выполняемые сценарием, не должны зависеть от данных, которые могут меняться 
//      в ходе выполнения сценария или от данных поступающих из устройств ввода-вывода.
//      Например, использование системного времени или команды генерирующие случайные 
//      значения.

// Чтобы обеспечить детерминированное поведение скриптов, Redis делает следующее:
// - Lua не экспортирует команды для доступа к системному времени или другим внешним 
//      состояниям;
// - если сценарий вызывает команду записи Redis после не детерминированной команды, 
//      такой как [RANDOMKEY, SRANDMEMBER, TIME], то Redis заблокирует этот сценарий
//      с ошибкой, то есть сценарии не выполняющие команды записи могут вызывать
//      не детерминированные команды;
// - для Redis 4.0: команды, которые возвращают элементы в случайном порядке, проходят
//      фоновую лексикографическую сортировку перед возвратом данных в сценарий Lua,
//      например, команда `redis.call("SMEMBERS", KEYS[1]);` всегда будет возвращать 
//      элементы Set в одном и том же порядке; начиная с Redis 5.0 такая сортировка
//      не выполняется; рекомендуется даже при разработке для Redis 4.0 полагаться
//      не на упорядоченность определенных команд Lua, а на документацию исходной 
//      команды;
// - функция Lua, генерирующая псевдослучайные числа math.random всегда будет 
//      генерировать одну и ту же последовательность чисел при каждом выполнении 
//      сценария, если только не используется math.randomseed;

// Остается возможность использовать команды для записи и случайного поведения с помощью 
//      простого трюка. Скрипт будет заполнять список из N случайных целых чисел:

//      require 'rubygems'
//      require 'redis'
//      
//      r = Redis.new
//      
//      RandomPushScript = <<EOF
//          local i = tonumber(ARGV[1])
//          local res
//          while (i > 0) do
//              res = redis.call('LPUSH',KEYS[1],math.random())
//              i = i-1
//          end
//          return res
//      EOF
//      
//      r.del(:mylist)
//      puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])

// Результат будет содержать точно следующие элементы:

//      > LRANGE mylist 0 -1
//           1) "0.74509509873814"
//           2) "0.87390407681181"
//           3) "0.36876626981831"
//           4) "0.6921941534114"
//           5) "0.7857992587545"
//           6) "0.57730350670279"
//           7) "0.87046522734243"
//           8) "0.09637165539729"
//           9) "0.74990198051087"
//          10) "0.17082803611217"

// Детерминированная версия сценария с возможностью создания случайных элементов
//      использует дополнительные аргументы для указания randomseed:

//      RandomPushScript = <<EOF
//          local i = tonumber(ARGV[1])
//          local res
//          math.randomseed(tonumber(ARGV[2]))
//          while (i > 0) do
//              res = redis.call('LPUSH',KEYS[1],math.random())
//              i = i-1
//          end
//          return res
//      EOF
//      
//      r.del(:mylist)
//      puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))

// Вывод сценария будет одним и тем же при одних и тех же аргументах. Передача 
//      аргумента для randomseed контролирует генерацию последовательности псевдо 
//      случайных чисел, что гарантирует одни и те же изменения при загрузке файла 
//      AOF и при запуске сценария репликами.

// Функции math.random и math.randomseed будут гарантированно иметь одинаковый 
//      результат независимо от архитектуры системы, в которой работает Redis. 

// --- 7.4.6 Выполнение в условиях нехватки памяти

// Если используемая память превышает максимальный предел maxmemory, то команда
//      записи, потребляющая память приведет к прерыванию сценария. Исключением
//      является функция redis.pcall. Если команда не требует выделения памяти 
//      (например, DEL или LREM), то Redis разрешит выполнение команд сценария, 
//      чтобы обеспечить атомарность. 

// Выполнение сценария может привести к превышению предельного значения maxmemory,
//      если перед выполнением первой команды записи в сценарии потребляемая память
//      достигает значения чуть меньшего, чем maxmemory. Когда сценарий начнет 
//      выполняться, другие команды могут увеличить потребление памяти и привысить
//      значение maxmemory. Для таких случаев следует использовать опцию настройки 
//      maxmemory-policy с любым значением, кроме noeviction. 

// Сценарии Lua должны быть максимально быстрыми, чтобы очистка памяти проходила
//      между выполнениями отдельных сценариев.

// --- 7.4.7 Флаги сценариев.

// Начиная с Redis 7.0 в сценариях можно указать флаги, которые определяют поведение
//      сценария. По умолчанию все сценарии могут читать и записывать данные.

// Флаги можно перечислить в первой строке сценария при помощи оператора '#!':

//      #!lua flags=no-writes,allow-stale
//      local x = redis.call('get','x')
//      return x

// --- Запуск.

module.exports = async () => {
    await redis_params();
    await redis_call_pcall();
    await redis_script_load();
};