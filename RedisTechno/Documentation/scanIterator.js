"use strict";

const redis = require("redis");



// --------------- 6. Scan Iterator.

//      https://redis.io/commands/scan
//      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator

async function redis_async_aterator() {

    // 
    const myAsyncIterable = {
        async*[Symbol.asyncIterator]() {
            yield "hello";
            yield "async";
            yield "iteration!";
        }
    };

    // 
    (async () => {
        for await (const x of myAsyncIterable) {
            console.log(x);
            // expected output:
            //    "hello"
            //    "async"
            //    "iteration!"
        }
    })();
}

// --- 6.1 SCAN.

// Временная сложность: O(1) для каждого вызова, O(N) для полной итерации.

// Команды [SCAN, SSCAN, HSCAN, ZSCAN] используются для перебора элементов.
//      - SCAN перебирает ключи в текущей выбранной базе данных Redis;
//      - SSCAN перебирает множества (Sets);
//      - HSCAN перебирает хэши (Hash);
//      - ZSCAN перебирает упорядоченные множества (Sorted Set);

// Итераторы следует использваоть для перебора больших коллекций элементов, поскольку
//      они не блокируют работу сервера, как это делают команды KEYS и SMEMBERS.
//      Команды SCAN не возвращают текущий снимок данных, то есть в процессе 
//      итерации элементы коллекции могут изменятся, в то время как блокирующие 
//      команды KEYS и SMEMBERS возвращают текущее состояние всех записей.

// Для команд [SSCAN, HSCAN, ZSCAN] первым аргументом является имя ключа соответствующего
//      типа коллекции. Команде SCAN итерирует ключи в текущей базе данных, поэтому 
//      первый аргумент указывать не нужно.

// Команды [SCAN, SSCAN, HSCAN, ZSCAN] возвращают массив из двух элементов:
//      курсор - это строка, которая представляет 64-битное число без знака; 
//      массив элементов, которым является:
//          для SCAN это список ключей;
//          для SSCAN это список элементов множества;
//          для HSCAN это пары: поле и значение;
//          для ZSCAN это пары: score и значение;

// Команда SCAN - это итератор на основе курсора, то есть при каждом вызове команды 
//      сервер возвращает значение курсора, которое должно использоваться в следующем
//      вызове команды. Итерация начинается со значения курсора равного 0 и заканчивается,
//      когда сервер вернет курсор равный 0.

//      > scan 0                    начало итерации
//          1) "17"                 новый курсор для использования в следующем вызове
//          2)  1) "key:12"         массив ключей
//              2) "key:8"
//              3) "key:4"
//              4) "key:14"
//              5) "key:16"
//              6) "key:17"
//              7) "key:15"
//              8) "key:10"
//              9) "key:3"
//             10) "key:7"
//             11) "key:1"
//      > scan 17                   продолжить итерацию
//          1) "0"                  последняя итерация, сервер вернул 0
//          2) 1) "key:5"
//             2) "key:18"
//             3) "key:0"

async function redis_scan_iterators() {

    // 
    const client = redis.createClient();
    client.on('error', (err) => {
        console.log(`--- redis client error: ${err}`);
    });

    // 
    await client.connect();
    console.log(`--- redis: connection`);

    // 
    console.log(`--- key: 
        --- SET = ${await client.SET('t1', '1')}
        --- SET = ${await client.SET('t2', '2')}
        --- SET = ${await client.SET('t3', '3')}
        --- SET = ${await client.SET('t4', '4')}
        --- SET = ${await client.SET('t5', '5')}
        --- SET = ${await client.SET('t6', '6')}
        --- SET = ${await client.SET('t7', '7')}
        --- SET = ${await client.SET('t8', '8')}
        --- SET = ${await client.SET('t9', '9')}
    `);

    // Настрйока итератора:

    let options = {
        TYPE: 'string',     // вернуть только строки
        MATCH: 't*',        // ключ должен начинаться с буквы t
        COUNT: 100          // количество элементов в итерации
    };

    // Команда SCAN реализуется через async iterators:

    for await (const key of client.scanIterator(options)) {
        console.log(`--- key: iterator 't*'
            --- GET ${key} = ${await client.GET(key)}
        `);
    }

    // Итераторы для команд [HSCAN, SSCAN, ZSCAN]:
    //      for await (const { field, value } of client.hScanIterator('hash')) { }
    //      for await (const member of client.sScanIterator('set')) { }
    //      for await (const { score, value } of client.zScanIterator('sorted-set')) { }

    // 
    console.log(`--- key: 
        --- HSET    = ${await client.HSET('user:1000', { username: "antirez", birthyear: "1977", verified: "1" })}
    `);

    // 
    for await (const { field, value } of client.hScanIterator('user:1000')) {
        console.log(`--- ${field} --- ${JSON.stringify(value)}`);
    }

    //
    client.quit();
}

// --- 6.2 Итерация хэша.

//      > hmset hash name Jack age 33
//          OK
//      > hscan hash 0
//          1) "0"
//          2) 1) "name"
//             2) "Jack"
//             3) "age"
//             4) "33"

// --- 6.3 Гарантии сканирования.

// Итератор возвращает элементы, которые находились в коллекции на момент запуска 
//      сканирования и не были из нее удалены. Итератор не возвращает элементы, 
//      которых не было в коллекции на момент начала сканирования. 

// Команды SCAN имеют ряд недостатков:
//      - элемент коллекции может быть возвращен несколько раз и приложение должно
//          самостоятельно обрабатывать такие случаи;
//      - элемент может быть не возвращен, если он был добавлен в коллекцию или 
//          удален из нее во время перебора;
//      - итератор может возвращать пустые элементы;

// --- 6.4 COUNT.

// Количество элементов, возвращаемых каждой итерацией не является постоянным значением,
//      но является адекватным с практической точки зрения. Для большой коллекции это
//      может быть несколько десятков элементов или все элементы сразу для небольших
//      коллекций. 

// Команда SCAN не гарантирует количество элементов, возвращаемых на каждой итерации, но
//      опция COUNT позволяет указать желаемое количество элементов.

// Значение COUNT по умолчанию равно 10.

// Значение COUNT может меняться между итерациями пока курсор передается от предыдущей
//      итерации к следующей. 

// Итерация коллекций достаточно больших, чтобы представить их в виде hash-таблицы, 
//      возвращает количество элементов большее, чем COUNT за одну итерацию.

// Итерация коллекций закодированных в виде intsets (небольшие множества целых чисел) 
//      или ziplists (небольшие хэши и множества, состоящие из небольших значений)
//      возвращают все элементы коллекции за одну итерацию.

// --- 6.5 MATCH.

// Опция MATCH позволяет указать шаблон ключа, которому должны соответствовать,
//      перебираемые итератором элементы. 

//      > sadd myset 1 2 3 foo foobar feelsgood
//          (integer) 6
//      > sscan myset 0 match f*
//          1) "0"
//          2) 1) "foo"
//             2) "feelsgood"
//             3) "foobar"

// Опция MATCH применяется, как фильтр после извлечения элементов из коллекции и перед 
//      возвратом данных клиенту. Если шаблон соответствует небольшому количеству 
//      элементов коллекции, то SCAN может возвращать пустой список результатов.

//      > scan 0 MATCH *11*
//          1) "288"
//          2) 1) "key:911"
//      > scan 288 MATCH *11*
//          1) "224"
//          2) (empty list or set)              пустой список
//      > scan 224 MATCH *11*
//          1) "80"
//          2) (empty list or set)              пустой список
//      > scan 80 MATCH *11*
//          1) "176"
//          2) (empty list or set)              пустой список
//      > scan 176 MATCH *11* COUNT 1000
//          1) "0"
//          2)  1) "key:611"                    последний запрос выполняется с опцией
//              2) "key:711"                        COUNT 1000
//              3) "key:118"
//              4) "key:117"
//              5) "key:311"
//              6) "key:112"

// --- 6.6 TYPE.

// Опция TYPE указывает команде SCAN возвращать объекты заданного типа. Этот параметр
//      доступен только для команды SCAN. Некоторые типы данных Redis реализованны через
//      другие типы, поэтому их невозможно отличить через команду SCAN, например:
//      GeoHashes, HyperLogLogs, Bitmaps, Bitfields. 

// Фильтр TYPE применяется после извлечения элементов из базы данных, поэтому этот параметр 
//      не уменьшает объем работы, которую должен выполнить сервер для завершения перебора.

//      > GEOADD geokey 0 0 value
//          (integer) 1
//      > ZADD zkey 1000 value
//          (integer) 1
//      > TYPE geokey
//          zset
//      > TYPE zkey
//          zset
//      > SCAN 0 TYPE zset
//          1) "0"
//          2) 1) "geokey"
//             2) "zkey"

// --- 6.7 Параллельные операции.

// Любое количество клиентов может одновременно выполнять итерацию одной и той же 
//      коллекции одновременно, поскольку состояние итератора находится в курсоре, 
//      который возвращается клиенту при каждом вызове SCAN. На стороне сервера 
//      состояние итератора не хранится, что также дает возможность завершить 
//      итерацию на полпути, никак не сигнализируя об этом серверу. Бесконечное 
//      количество итераций может быть запущено и никогда не остановлено без 
//      каких-либо проблем.

// Вызов SCAN с недопустимым курсором приведет к неопределенному поведению, но никогда 
//      к сбою. Допустимыми курсорами являются:
//      - 0 при запуске итерации;
//      - значение, возвращенное предыдущим вызовом SCAN для продолжения итерации;

// Алгоритм итератора завершит свою работу, если размер итерируемой коллекции остается 
//      ограниченным заданным максимальным размером, иначе итерация постоянно растущей
//      коллекции никогда не завершится. 

// --- 6.8 Возврат команд [SSCAN, HSCAN, ZSCAN].

// Команды SCAN могут возвращать все элементы коллекций типа [Set, Hash, Sorted Set] 
//      за одну итерацию, независимо от значения опции COUNT. При реализации итератора
//      на основе курсора, сканируемый тип данных должен быть представлен в виде 
//      хэш-таблицы. Но Redis использует оптимизацию памяти, при которой небольшие 
//      коллекции храняться как один закодированный элемент в памяти до тех пор, пока
//      не достигнут заданного количества элементов или размера. В этом случае SCAN
//      итерирует коллекцию, как атомарный объект и возвращает ее целиком. Если коллекция 
//      выростает до определенного размера, то для её хранения в памяти Redis начинает 
//      использовать хеш-таблицу и SCAN итерирует коллекцию, как перечислимый объект.

// Это поведение справедливо для команд [SSCAN, HSCAN, ZSCAN], но не для SCAN, поскольку 
//      ключи в базе данных Redis всегда представлены в виде хеш-таблицы.

// Максимальное количество элементов при возврате закодированной коллекции будет зависеть
//      от ограничения на преобразование закодированной коллекции в хэш-таблицу, которое 
//      настраивается пользователем.

// --- Запуск.

(async () => {
    await redis_async_aterator();
    await redis_scan_iterators();
})();