// --------------- 2. Запросы GraphQL.

// --- 2.1 GraphQL и SQL.

// SQL (Structured Query Language - структурированный язык запросов) - это язык,
//      предназначенный для доступа и управления данным в базе. SQL позволяет
//      получить несколько записей с помощью одной команды, конкретную запись
//      по ее идентификатору или связанные данные из нескольких таблиц. 

// Команды SQL интуитивно понятны [SELECT, INSERT, UPDATE, DELETE] и позволяют
//      перейти к REST, что требует использования соответствующих HTTP-методов
//      [GET, POST, PUT, DELETE]. Подобно SQL запросы GraphQL могут возвращать 
//      связанные данные, изменять и удалять данные.

// GraphQL и SQL являются языками запросов, но существенно отличаются:

// - SQL определяет запросы к базе данных, а GraphQL к API.

// - Данные SQL хранятся в таблицах. Данные GraphQL можно хранить в любом 
//      месте: в нескольких базах данных, в нескольких файловых системах, 
//      API REST, вебсокетах и других API GraphQL.

// - SQL - это язык запросов для баз данных. GraphQL - это язык запросов 
//      для интернета.

// - GraphQL и SQL имеют разный синтаксис. Вместо SELECT в GraphQL используется 
//      команда Query, которая лежит в основе всех операций GraphQL. GraphQL  
//      вместо [INSERT, UPDATE, DELETE] выполняет все изменения данных через
//      один тип данных: Mutation. 

// - GraphQL включает тип Subscription, который применяется для отслеживания 
//      изменений данных через сокеты. SQL такого функционала не имеет.

// --- 2.2 Запросы GraphQL.

// Запросы (query) GraphQL - это простые строки, которые отправляются 
//      POST-запросами в конечную точку GraphQL.
//      {
//          allLifts 
//          {
//              name
//          }
//      }

// Отправка запроса при помощи curl:
//      curl 'http://snowtooth.herokuapp.com/'
//          -H 'Content-Type: application/json'
//          --data '{"query":"{allLifts{name}}"}'

// Ответ в формате JSON будет содержать запрошенные данные в поле data или 
//      описание ошибки в поле errors.

// Чтобы выполнить операцию изменения данных запрос GraphQL должен содержать 
//      мутацию и данные, необходимые для изменения. 
//      mutation {
//          setLiftStatus(id: "panorama", status: OPEN) {
//              name
//              status
//          }
//      }

// Мутация изменит значение поля status на OPEN для записей с идентификатором 
//      "panorama".
//      curl 'http://snowtooth.herokuapp.com/'
//          -H 'Content-Type: application/json'
//          --data '{"query":"mutation{setLiftStatus(id: \"panorama\", status: OPEN){name status}}"}

// --- 2.3 query.

// Для запроса данных используется операция query. Запрос описывает данные, 
//      которые требуется получить от сервера GraphQL. Поля в запросе указывают,
//      какие данные следует получить. Иерархия полей в запросе отображается
//      на такие же поля в ответе JSON. Успешный запрос возвращает JSON. Неудачный 
//      запрос возвращает JSON, содержащий ошибку.
//
//      query {             |   json {
//          allLifts {      |       "allLifts": [            
//              name        |           { name: "", status: "" },            
//              status      |           { name: "", status: "" },
//          }               |       ]         
//      }                   |   }     

// Несколько операций можно поместить в один запрос, то есть можно получать разные
//      типы данных в одном запросе.
//      query liftsAndTrails {
//          // запрос количества подъемников со статусом OPEN
//          liftCount(status: OPEN)
//          //  запрос всех подъемников
//          allLifts {
//              name
//              status
//          }
//          // запрос всех трасс
//          allTrails {
//              name
//              difficulty
//          }
//      }

// query - это корневой тип GraphQL. Корневой тип - это тип, который сопоставляется
//      с операцией, а операции представляют собой корни документа запроса. В схеме 
//      определяются поля доступные для запроса в API GraphQL.

// Запросы состоят из блоков, которые включают наборы полей в фигурных скобках.
//      Эти блоки называются выборками. Поля в выборках напрямую связаны с типами 
//      GraphQL. Поля [liftCount, allLifts, allTrails] определены в типе query.
//      Выборки можно встраивать друг в друга. 

// В ответе JSON, поля имеют имена указанные в выборке. Имена полей можно изменить
//      в объекте ответа, если указать псевдонимы.
//      query liftsAndTrails {              |   "data": {                            
//          open: liftCount(status: OPEN)   |       "open": 0,                                       
//          chairlifts: allLifts {          |       "chairlifts": [                                
//              liftName: name              |           { "liftName": "", "status": "" }                            
//              status                      |       ],                    
//          }                               |   }           
//      }

// Результаты запроса GraphQL можно фильтровать при помощи аргументов. 
//      Аргументы - это пары ключ/значение, связанные с полем запроса. 
//      query closedLifts {
//          // фильтрует результаты для значений "CLOSED"
//          allLifts(status: "CLOSED", sortBy: "name") {
//              name
//              status
//          }
//      }

// Аргументы можно использовать для выбора данных по уникальному идентификатору.
//      query jazzCatStatus {
//          Lift(id: "jazz-cat") {
//              name
//              status
//              night
//              elevationGain
//          }
//      }

// --- --- ребра и соединения

// Поля могут быть либо скалярными типами, либо типами объектов. 

// Скалярные типы являются листьями выборок. Имеется пять встроенных скалярных 
//      типов: целое число (Int), вещественное число (Float), строка (String), 
//      булево значение (Boolean), уникальный идентификатор (ID). Int и Float
//      возвращают числа JSON, а String и ID возвращают строки JSON. Boolean
//      возвращает true/false. 

// Типы объектов GraphQL представляют собой группы из нескольких полей, определнные 
//      в схеме. Они устанавливают форму возвращаемого объекта JSON. Объекты можно 
//      встраивать друг в друга, чтобы получать связанные данные.

//      query trailsAccessedByJazzCat {
//          Lift(id:"jazz-cat") {
//              capacity
//              // поле trailAccess имеет тип объекта Trail и возвращает 
//              //      отфильтрованный список маршрутов, при фильтрации
//              //      используется информация родительского объекта
//              //      Lift с указанным id
//              trailAccess {
//                  name
//                  difficulty
//              }
//          }
//      }

// Операция запрашивает соединение 'один ко многим' между типом Lift и типом Trail.
//      Если граф начинается с узла Lift, то можно добраться до нескольких вершин 
//      Trail, которые связаны через ребро с названием trailAccess. Чтобы граф 
//      считался неориентированным, должна быть связь от узла Trail к вершине Lift.

//      query liftToAccessTrail {
//          Trail(id:"dance-fight") {
//              groomed
//              accessedByLifts {
//                  name
//                  capacity
//              }
//          }
//      }

// --- --- фрагменты

// Запрос GraphQL может содержать определения операций и фрагментов. 

// Фрагменты - это выборки определенных типов, которые можно повторно 
//      использовать в нескольких операциях. Фрагменты создаются с помощью 
//      идентификатора fragment и указанием типа, связаного с фрагментом.
//      Фрагменты позволяют быстро изменять выборки для нескольких запросов.

// две выборки содержат одинаковый набор полей для получения объектов Lift
//      query {
//          Lift(id: "jazz-cat") {
//              name
//              status
//              capacity
//              night
//              elevationGain
//              trailAccess {
//                  name
//                  difficulty
//              }
//          }
//          Trail(id: "river-run") {
//              name
//              difficulty
//              accessedByLifts {
//                  name
//                  status
//                  capacity
//                  night
//                  elevationGain
//              }
//          }
//      }

// Фрагмент, который уменьшает избыточность в запросе. Фрагмент называется 
//      liftInfo и является выборкой типа Lift. Объявление фрагмента в схеме:
//      fragment liftInfo on Lift {
//          name
//          status
//          capacity
//          night
//          elevationGain
//      }

// Добавить поля фрагмента liftInfo в выборку можно с помощью синтаксиса 
//      аналогичного оператору spread из JavaScript.

// фрагмент применяется для выборки полей в двух позициях запроса 
//      query {
//          Lift(id: "jazz-cat") {
//              ...liftInfo
//              trailAccess {
//                  name
//                  difficulty
//              }
//          }
//          Trail(id: "river-run") {
//              name
//              difficulty
//              accessedByLifts {
//                  ...liftInfo
//              }
//          }
//      }

// При определении фрагмента указывается тип поля, для которого можно применять
//      фрагмент. Фрагмент liftInfo можно применять для выборки полей типа 
//      Lift, а фрагмент trailInfo для полей типа Trail. Можно создавать любое
//      количество фрагментов и задействовать их взаимозаменяемо.
//      query {
//          Lift(id: "jazz-cat") {
//              ...liftInfo
//              trailAccess {
//                  ...trailInfo
//              }
//          }
//          Trail(id: "river-run") {
//              ...trailInfo
//              groomed
//              trees
//              night
//          }
//      }
//      fragment trailInfo on Trail {
//          name
//          difficulty
//          accessedByLifts {
//              ...liftInfo
//          }
//      }
//      fragment liftInfo on Lift {
//          name
//          status
//          capacity
//          night
//          elevationGain
//      }

// Фрагменты можно применять в сочетании с другими полями в выборке. Несколько 
//      фрагментов одного типа можно комбинировать в одной выборке.
//      query {
//          allTrails {
//              ...trailStatus
//              ...trailDetails
//          }
//      }
//      fragment trailStatus on Trail {
//          name
//          status
//      }
//      fragment trailDetails on Trail {
//          groomed
//          trees
//          night
//      }

// --- --- объединения

// Объединения позволяют связывать разные типы объектов в одной выборке. 
//      Для этого используются встроенные фрагменты, которые указывают выборки
//      конкретным типам непосредственно в запросе. У таких фрагментов нет имен. 
//      query schedule {
//          agenda {
//              // выборка если AgendaItem является Workout
//              ...on Workout {
//                  name
//                  reps
//              }
//              // выборка если AgendaItem является Group
//              ...on Group {
//                  name
//                  subject
//                  students
//              }
//          }
//      }

// Результатом запроса будет массив, содержащий различные типы объектов.
//      {
//          "data": {
//              "agenda": [
//                  { "name": "", "subject": "", "students": 1 },
//                  { "name": "", "reps": 10 },
//                  { "name": "", "subject": "", "students": 2 },
//                  { "name": "", "subject": "", "students": 3 },
//                  { "name": "", "reps": 20 },
//                  { "name": "", "reps": 30 }
//              ]
//          }
//      }

// Для запроса объединения можно задействовать именованные фрагменты.
//      query today {
//          agenda {
//              ...workout
//              ...study
//          }
//      }
//      fragment workout on Workout {
//          name
//          reps
//      }
//      fragment group on Group {
//          name
//          subject
//          students
//      }

// --- --- интерфейсы

// Интерфейс - это абстрактный тип, устанавливающий список полей, которые должны
//      быть включены в тип объекта. Если тип объекта реализует интерфейс, то он
//      будет включать все поля интерфейса и несколько собственных полей.
//      Интерфейсы позволяют возвращать несколько типов объектов в одном поле.

// Поле agenda возвращает интерфейс ScheduleItem, который определяет поля: name,
//      start, end. Если типы Group и Workout реализуют интерфейс ScheduleItem,
//      то они должны содержать эти поля.

//      query schedule {
//          agenda {
//              name
//              start
//              end
//          }
//      }

// При запросе интерфейса можно использовать фрагменты для выборки дополнительных 
//      полей при возврате определенного типа объекта.
//      query schedule {
//          agenda {
//              name
//              start
//              end
//              // дополнительно запрашивает reps, когда ScheduleItem 
//              //      является Workout
//              ...on Workout {
//                  reps
//              }
//          }
//      }

// --- 2.4 Мутации.

// Запросы GraphQL используются для чтения данных. Для изменения данных используются
//      мутации. Как и запросы, мутации имеют имена и выборки, возвращающие скаляры
//      или типы объектов. 

// Mutation - корневой тип данных. Схема GraphQL будет определять поля, доступные 
//      для этого типа. Мутация удаления может возвращать true, если данные были
//      удалены или false, если произошла ошабка.

// Опасная мутация удаления данных.
//      mutation burnItDown {
//          deleteAllData
//      }

// Мутация создания данных.
//      mutation createSong {
//          // - значения title, numberOne, performerName передаются в мутацию
//          //      в качестве аргументов
//          // - если мутация возвращает объект, то следует указать выборку 
//          //      после мутации
//          addSong(title:"No Scrubs", numberOne: true, performerName:"TLC") {
//              id
//              title
//              numberOne
//          }
//      }

// Возможный результат:
//      {
//          "data": {
//              "addSong": { "id": "...", "title": "...", "numberOne": true }
//          }
//      }

// Мутация изменения данных.
//      mutation closeLift {
//          // после выполнения мутации будут возвращены объекты с указанной 
//          //      выборкой полей
//          setLiftStatus(id: "jazz-cat", status: CLOSED) {
//              name
//              status
//          }
//      }

// --- --- переменные

// Переменные применяются для передачи динамических значений в мутации.
//      Переменным всегда предшествует символ $.

//      mutation createSong($title:String! $numberOne:Int $by:String!) {
//          addSong(title:$title, numberOne:$numberOne, performerName:$by)
//          {
//              id
//              title
//              numberOne
//          }
//      }

// Данные отправляются как объект JSON с полями соответствующими переменным.
//      {
//          "title": "No Scrubs",
//          "numberOne": true,
//          "by": "TLC"
//      }

// --- 2.5 Подписки.

// Подписка - это тип GraphQL, который позволяет перехватывать события GraphQL
//      для обновления данных в реальном времени. Подписка является корневым типом.
//      Изменения данных, которые клиенты могут отслеживать, определяются в схеме
//      как поля с типом subscription. Чтобы прекратить отслеживание следует 
//      отказаться от подписки. 

// Live Likes (лайки в реальном времени) - это сценарий основанный на подписках.
//      Каждый клиент подписывается на событие и оповещается в реальном времени
//      о новых лайках.

// Полписка отслеживает изменения объектов Lift через WebSocket.
//      subscription {
//          liftStatusChange {
//              name
//              capacity
//              status
//          }
//      }

// Мутация вызывает изменение поля status объекта Lift, что приводит к оповещению
//      клиента через подписку.
//      mutation closeLift {
//          setLiftStatus(id: "astra-express", status: HOLD) {
//              name
//              status
//          }
//      }

// --- 2.6 Самодиагностика.

// Самодиагностика - это возможность запрашивать метаданные о схеме API GraphQL.
//      Запросы самодиагностики следуют обычным правилам языка запросов GraphQL.
//      Например, в запросах можно использовать фрагменты.

// Чтобы узнать доступные типы GraphQL можно выполнить запрос __schema. Запрос
//      вернет все доступные типы: корневые, пользовательские, скалярные.
//      query {
//          __schema {
//              types {
//                  name
//                  description
//              }
//          }
//      }

// Чтобы получить описание определенного типа можно выполнить запрос __type
//      с указанием имени нужного типа в качестве аргумента.
//      query liftDetails {
//          // запрос покажет все поля типа объекта Lift
//          __type(name:"Lift") {
//              name
//              fields {
//                  name
//                  description
//                  type {
//                      name
//                  }
//              }
//          }
//      }

// Поля доступные для корневых типов.
//      query roots {
//          __schema {
//              queryType {
//                  ...typeFields
//              }
//              mutationType {
//                  ...typeFields
//              }
//              subscriptionType {
//                  ...typeFields
//              }
//          }
//      }
//      fragment typeFields on __Type {
//          name
//          fields {
//              name
//          }
//      }

// --- 2.7 Абстрактные синтаксические деревья.

// Документ запроса представляет собой строку, которая отправляется на сервер
//      GraphQL. Перед выполнением операций проводится лексический анализ строки 
//      запроса, результатом которого является абстрактное синтаксическое дерево.
//      Абстрактное синтаксическое дерево (АСД) - это иерархический объект, 
//      который содержит поля с описанием запроса GraphQL. GraphQL анализирует АСД, 
//      чтобы проверить на соответствие синтаксису языка GraphQL и текущей схемы. 
//      Если синтаксис запроса правильный и схема содержит запрашиваемые поля и 
//      типы, то операция может быть выполнена, иначе возвращается ошибка.

// Запрос является документом GraphQL. Документ должен содержать хотя бы одно
//      определение. Определения могут иметь один из двух типов:
//      OperationDefinition или FragmentDefinition.

// OperationDefinition может содержать один из трех типов операций:
//      mutation, query, subscription. Каждое определение операции содержит
//      OperationType и SelectionSet.

// SelectionSet представляет выборку полей указанных в фигурных скобках после
//      каждой операции. Выборки SelectionSet могут быть вложены друг в друга.

// Объект АСД легче модифицировать, чем строку. Например, можно добавить 
//      дополнительную выборку полей SelectionSet.

// Документ содержит три определения, две операции и один фрагмент.
//      // определение операции запроса
//      query jazzCatStatus {
//          //  поле Lift является SelectionSet для запроса jazzCatStatus
//          Lift(id: "jazz-cat") {
//              // вложенная выборка SelectionSet для полей [name, night,
//              //      elevationGain, trailAccess]
//              name
//              night
//              elevationGain
//              trailAccess {
//                  //  вложенная выборка SelectionSet для полей [name, difficulty]
//                  name
//                  difficulty
//              }
//          }
//      }
//      // определение операции мутации
//      mutation closeLift($lift: ID!) {
//          // поле setLiftStatus является SelectionSet для запроса closeLift
//          setLiftStatus(id: $lift, status: CLOSED ) {
//              ...liftStatus
//          }
//      }
//      // определение фрагмента
//      fragment liftStatus on Lift {
//          name
//          status
//      }