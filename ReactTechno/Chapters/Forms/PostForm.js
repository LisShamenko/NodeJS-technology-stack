// --- 8. Работа с формами в React.

// Пользователи должны видеть предупреждение, когда они нарушают правила валидации 
//      вводимых данных, в этом случае валидация должна выполняться в браузере, 
//      чтобы обеспечить плавность UI и дополнительный уровень защиты. Аналогичная 
//      валидация должна выполняться и на сервере, так как сервер не может полагаться

// Для сетевых запросов используется библиотека 'isomorphic-fetch', которая 
//      использует API Fetch браузера, а также работает на сервере.

// импорт
import React from 'react';
import PropTypes from 'prop-types';

// пакет 'bad-words' позволяет фильтровать слова
import Filter from 'bad-words';

// компонент отвечает за создание постов
class PostForm extends React.Component {
    constructor(props) {
        super(props);

        // --- обработчики: привязка

        // обработчик для отправки формы
        this.handleSubmit = this.handleSubmit.bind(this);

        // обработчик для валидации формы
        this.handlePostChange = this.handlePostChange.bind(this);

        // установить начальное состояние
        this.state =
        {
            // изменение состояния компонента 
            content: '',

            // --- валидация данных

            // Разработка валидации данных форм должна включать следующие этапы:
            // 
            //      1. Следует определить требования к данным, что поможет определить  
            //          основные рекомендации по исправлению данных.
            //      2. Разработка компонентов с проверкой данных, которые позволят  
            //          пользователям предоставлять значимые данные.
            //      3. Определить способы устранения несоответствий в данных,  
            //          предоставляемых пользователями.

            // флаг валидации
            isValid: false,
            isControl: true,
        };

        // фильтр слов
        this.filter = new Filter();
    }

    // обработчик для валидации формы, обработчики событий получают событие 
    //      в качестве аргумента, событие компонента React является оберткой 
    //      для браузерного события
    handlePostChange(event) {

        console.log('--- handlePostChange --- start');

        // --- обработчики: event.target

        // event.target - это ссылка на DOM-элемент, который отправил событие, 
        //      аналогично обычному браузерному коду.
        console.log(`
            --- event = ${event} 
            --- event.target = ${event.target}
        `);

        // Работа с формами в React заключается в получении событий в обработчиках и 
        //      использование этих событий для обновления данных компонента. 

        // state и props - это два основных способа, с помощью которых React 
        //      позволяет работать с данными.

        // Одна из основных задач React заключается в синхронизации DOM браузера 
        //      с виртуальной DOM, которая собирается из компонентов. Таким образом
        //      при вводе в текстовое поле, символы не отображаются сразу, так как
        //      React должен сначала изменить виртуальную DOM. Вместо этого, 
        //      события ввода отправляются на обработку в React, где в обработчиках 
        //      принимается решение об изменении данных, меняется состояние компонента,
        //      после чего React синхронизирует виртуальную DOM с фактической. 
        //      
        //      ввод символа => генерация события => получение события        =>
        //      в textarea         onChange          в обработчике компонента
        //      -----------------------------------------------------------------
        //      изменение state => React меняет DOM браузера
        //      -----------------------------------------------------------------

        // значение value из DOM элемента textarea
        const content = event.target.value;

        // --- валидация данных: 3. устранение несогласованности данных

        // фильтрация
        let clear_content;
        try {
            clear_content = this.filter.clean(content);
        }
        catch (err) {
            console.log(`--- error of 'bad-words' --- error: ${err}`);
            clear_content = content;
        }

        // обновить this.state с учетом фильтра и с флагом валидации
        this.setState(() => {
            return {
                // изменение состояния компонента 
                content: clear_content,

                // --- валидация данных: 1. определить ограничения данных

                // правило валидации: контент не должен превышать заданной длины
                isValid: clear_content.length <= 280
            };
        });

        //
        console.log('--- handlePostChange --- end');
    }



    // обработчик для отправки формы
    handleSubmit(event) {

        console.log(`--- handleSubmit --- start`);

        // --- валидация данных: 2. выполнить валидацию данных

        // предотвратить событие 'submit' по умолчанию
        event.preventDefault();

        // проверка валидации
        if (!this.state.isValid) {
            return;
        }

        // --- создание сообщений

        // убедится в наличии функции onSubmit
        if (this.props.onSubmit) {

            // объект с данными нового поста
            const newPost = {
                content: this.state.content,
                userId: this.props.user.id,
            };

            // обратный вызов onSubmit:
            //      дочерний компонент несет ответственность за передачу
            //      данных в родительский компонент, чтобы тот мог передать 
            //      их на сервер

            // отправить данные нового поста в родительский компонент через
            //      функцию обратного вызова
            this.props.onSubmit(newPost);

            // сброс состояния компонента для создания следующего поста
            this.setState({
                content: '',
                isValid: null,
            });
        }

        //
        console.log(`--- handleSubmit --- end --- state = ${this.state}`);
    }



    // 
    render() {

        if (this.state.isControl) {

            // --- использование контролируемых компонентов

            // React позволяет отслеживать события как в обычном браузерном коде, независимо 
            //      от версий различных браузеров, то есть не нужно беспокоиться о различиях 
            //      между браузерами.

            // Отслеживаются два события:
            // - onChange, срабатывает при изменении ввода, новое значение элемента формы
            //      можно получить при помощи выражения 'event.target.value'
            // - onClick, срабатывает при щелчке мыши на элементе, что позволяет определить
            //      момент нажатия на кнопку и отправить сообщение на сервер

            return (
                // обработчики событий передаются в компоненты: button и textarea
                <div>
                    <button onClick={this.handleSubmit}>Post</button>
                    <textarea
                        // содержимое DOM элемента textarea определяется значением 
                        //      из this.state
                        value={this.state.content}
                        onChange={this.handlePostChange}
                    />
                </div>
            );
        }
        else {
            
            // --- использование неконтролируемых компонентов

            return (
                <div>
                    <button onClick={this.handleSubmit}>Post</button>
                    <textarea
                        // содержимое DOM элемента textarea не контролируется React
                        onChange={this.handlePostChange}
                    />
                </div>
            );
        }
    }
}

// валидация свойств
PostForm.propTypes = {

    // --- создание сообщений

    // определяется свойство, которому передается функция обратного вызова
    //      для передачи данных в родительский компонент
    onSubmit: PropTypes.func.isRequired,
    user: PropTypes.object,
}

// экспорт
export default PostForm;