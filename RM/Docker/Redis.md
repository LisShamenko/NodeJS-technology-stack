# Docker Redis

## [Spin up Redis on Docker and learn basic commands](https://www.youtube.com/watch?v=ZkwKyUZWkp4)

-	терминал 1
	```
	docker run --name rds -p 6379:6379 redis
	docker exec -it rds redis-cli
	set name "hussein"
	get name
	set nametemp "edmond" EX 10
	get nametemp
	get baloony
	exists nametemp
	exists name
	del name
	exists name
	append name "hussein"
	get name
	append name "john"
	get name
	subscribe newvideos
	```

-	терминал 2
	```
	docker exec -it rdb redis-cli
	publish newvideos "REDIS CRASH COURSE ISUP! BABES"
	publish newvideos "c# crash course"
	```

____

## РЕАЛИЗАЦИЯ

-	создать контейнер redis
	```
	lisandrsh@server:~$ docker run --name rds -p 6379:6379 redis
	Unable to find image 'redis:latest' locally
		...
	```
-	заверишть команду 
	```
	^C
	1:signal-handler (1619523691) Received SIGINT scheduling shutdown...
		...
	```

-	повторно запустить остановленный контейнер
	```
	lisandrsh@server:~$ docker start rds
	```

-	контейнер запущен в фоновом режиме
	```
	lisandrsh@server:~$ docker ps -a
	CONTAINER ID   IMAGE    COMMAND                  CREATED              	STATUS              PORTS                      NAMES
	b9f9348d363a   redis    "docker-entrypoint.s…"   About a minute ago   Up About a 	minute   0.0.0.0:6379->6379/tcp     rds
		...
	```

-	подключится к redis с другого терминала
	```
	lisandrsh@server:~$ docker exec -it rds redis-cli
	```

	-	назначить объект
		```
		127.0.0.1:6379> set name "hussein"				OK
		127.0.0.1:6379> get name						"hussein"
		127.0.0.1:6379> get baloony						(nil)
		```
	
	-	назначить временный объект
		```
		127.0.0.1:6379> set nametemp "ed" EX 10			OK
		127.0.0.1:6379> get nametemp					"ed"
		127.0.0.1:6379> get nametemp					(nil)
		```
	
	-	проверить наличие объекта
		```
		127.0.0.1:6379> exists name						(integer) 1
		127.0.0.1:6379> del name						(integer) 1
		127.0.0.1:6379> exists name						(integer) 0
		```
	
	-	добавить строку к значению
		```
		127.0.0.1:6379> append name "hussein"			(integer) 7
		127.0.0.1:6379> get name						"hussein"
		127.0.0.1:6379> append name " john"				(integer) 12
		127.0.0.1:6379> get name						"hussein john"
		```
	
	-	прием сообщений
		```
		127.0.0.1:6379> subscribe newvideos
		Reading messages... (press Ctrl-C to quit)
		1) "subscribe"
		2) "newvideos"
		3) (integer) 1
		1) "message"
		2) "newvideos"
		3) "redis 1"
		```

-	другой терминал 
	```
	lisandrsh@server:~$ docker exec -it rds redis-cli
	```

	-	публикация сообщения
		```
		127.0.0.1:6379> publish newvideos "redis 1"		(integer) 1
		```

____

## [Redis - основы и практическое использование](https://www.youtube.com/watch?v=AimUYjKs3pQ)

-	запуск CLI

	ввести в консоли команду 'redis-cli', что запустит Redis CLI 
	
	'host:port>', где port равен 6379 это стандартный порт redis

	```
	127.0.0.1:6379>quit
	```

-	key-value хранилище, все значения сохраняются как строки
	```
	SET foo 42									// SET key value
	GET foo										// GET key
	```
-	возвращает 0 или 1
	```
	EXISTS foo 									// EXISTS key
	```
-	удаляет все данные из памяти
	```
	FLUSHALL 
	```
-	сохранить значение на 20 секунд
	```
	SET bar "Hello" EX 20
	```
-	выведет (nil) через 20 секунд
	```
	GET bar
	```
-	добавит строку в foo, возвращает количество символов
	```
	APPEND foo " world"
	```
-	возвращает все ключи, нельзя использовать в реальных приложениях, т.к. очень медленная
	```
	KEYS *
	```
-	увеличивает значение на 1, интерпритирует сроки как числа
	```
	INCR foo
	```
-	уменьшает значение на 1, внутри все равно хранится как строка
	```
	DECR foo
	```

____

-	redis поддерживает сложные типы данных

	-	хэш-таблицы (ассоциативные массивы, объекты состоящие из полей)
		-	задать два поля для ключа person1
			```	
			HSET person1 name "Vasya"	
			HSET person1 age 19
			```	
		-	указываем ключ объекта и его поле
			```
			HGET person1 age
			```
		-	вернуть хэш полностью
			```
			HGETALL person1
			1) "name"
			2) "Vasya"
			3) "age"
			4) "19"
			```
		-	вернуть только значения
			```
			HVALS
			```
		-	вернуть только ключи
			```
			HKEYS
			```
	
	-	множества - хранилище уникальных значений, не сортированных (не упорядоченные, без повторов)
		-	добавить в множество persons значение 
			```
			SADD persons "Vasya"
			```
		-	получить все значения
			```
			SMEMBERS persons
			```
		-	интерпритация юникода: "Вася" -> "\xd0\x92\xd0\xb0\xd1\x81\xd1\x8f"
			[Unicode code converter](https://r12a.github.io/app-conversion/)

		- реализованы алгоритмы хитрые из теории множеств
			-	кординальное число - количество элементов в множестве
				```
				SCARD persons			
				```
			-	объединение множеств, возвращает новое множества
				```
				SUNION persons another	
				```
			-	вычитание множеств, возвращает новое множества
				```
				SDIFF persons another	
				```
			-	пересечение множеств, возвращает новое множества
				```
				SINTER persons another	
				```
			-	возвращает и удаляет случайный элемент из множества
				```
				SPOP persons 			
				```

	-	списки - последовательность значений, которые упорядочены по порядку их создания, первый созданный становится первым элементом в списке
		-	добавляет значение в начало списка
			```
			LPUSH mylist "one"
			```
		-	добавить значение в конец списка
			```
			RPUSH mylist "two"
			```
		-	взять значение из начала списка, начиная с 0 элемента заданное 		количество элементов (-1 все значения)
			```
			LRANGE mylist 0 -1
			```
		-	забрать одно значение из начала (left) списка
			```
			LPOP mylist
			```
		-	забрать одно значение из конца (right) списка
			```
			RPOP mylist
			```
		-	длина списка
			```
			LLEN mylist
			LINSERT mylist BEFORE first "zero"
			```
		-	из списка легко сделать очередь, очередь задач:
			1 сервис создает сложный ключ записывает в хэш redis объект-значений, ключ добавляется в список
			2 сервис читает из списка ключ и по ключу выбирает из хэша объект-значений

	-	упорядоченное множество - хранилище уникальных значений, сортированных
		-	добавить значение в упорядоченное множество, упорядочивание будет выполняться по году
			```
			ZADD persons "порядковое число" "значение"
			ZADD persons 1980 "Vasya"
			```
		-	получить значения в упорядоченном виде
			```
			ZRANGE persons 0 -1 WITHSCORES
			```

____

-	есть команды уточняющие порядок сравнения (например, лексикографическое: "2" > "11")
-	самое частое использование redis, при том что данные могут теряться: кэш или межсервисное взаимодействие
	```
	ZREVRANGE							
	```

-	транзакции - возможность начать запись команд при помощи команды multi, которые не будут выполняться мгновеено, а будут ожидать вызова (реляционные: последовательность команд, которые выполняются как единое целое)
	-	переход в режим когда команды не выполняются а набираются 
		```
		MULTI
		```
	-	две команды
		```
		INCR foo	// 1 команда
		DECR bar	// 2 команда
		```
	-	выполнить все введенные команды
		```
		EXEC
		```
	-	сбросить список команды и выйти из MULTI
		```
		DISCARD
		```

	-	1 ошибка: если одна из команд была введена не верно то транзакция не будет выполнена
	-	2 ошибка: если произошла ошибка при выполнении самой команды, то redis не отменит всю транзакцию, а выполнит все команды до и после ошибки
	-	можно сказать что транзакции redis это макрос

____

-	redis можно использовать: как хранилище ключ-значение, как inmemory БД, как сервер очередей, как сервер сообщений

	-	client 1: подписаться к каналу news, переходит в режим прослушивания канала
		```
		SUBSCRIBE news
		```
	-	client 2: публикует сообщение в канале
		```
		PUBLISH news "Hello!"
		```

____

-	redis - это база данных, очень быстрая, в которой данные храняться в памяти, но при этом имееют персистентное хранилище. Является одновременно key-value хранилищем, хранилищем сложных структур данных, сервером очередей, службой подписки сообщений. Неограничено масштабируется, есть понятие репликации.

-	rabbitmq - это просто очередь

-	Персистентные структуры данных (англ. persistent data structure) — это структуры данных, которые при внесении в них каких-то изменений сохраняют все свои предыдущие состояния и доступ к этим состояниям.

-	как применяется:
	-	кэширование, не быстрее но удобнее memcache
	-	чаты и ситемы обмена сообщениями
	-	различные очереди задач
	-	сортируемые таблицы
	-	мониторинг процессов
		-	на redis была организована очередь
		-	один php сервис не прерывно добавлял в эту очередь информацию о файлах готовых к обработке
		-	другой php процесс брал из очереди инфу о файле и запускал отдельным процессом воркер для обработки этого файла
		-	в redis отправляли инфу о том что обработка запущена
		-	требование: при 8 ядер не более 8 процессов одновременно, что можно было определить из редиса
		-	каждый процесс отправлял инцу в редис: обработку начал
		-	в php есть тики (возможность через определенные промежутки что то делать), tics, каждый процесс писал текущее время обработки сообщая что он живой, можно было в любой момент из редиса получить инфу о процессах которые 5 секунд уже ничего не писали, и сделать вывод что они зависли
		-	каждый процесс писал в редис текущий прогресс обработки 
		-	очень дешевое решение, микрохарактеристическое время микросекунды 
	
-	типы хранения данных в памяти:
	-	в оперативной памяти и сохранение на диске через временной интервал
	-	в оперативной памяти и с логированием каждой операции (самый надежный вариант)
	-	без сохранения на диск (самый не надежный)

-	два режима персистентного хранения либо раз в секунду скидывать состоние либо при каждой операции записи 
-	нет подкачки с диска, все данные храняться в памяти
